//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { BaseClient } from './base-client';
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class GeneralClient extends BaseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    admin_CheckAdminCanAccess(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CheckAdminCanAccess(_response));
        });
    }

    protected processAdmin_CheckAdminCanAccess(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    admin_GetData(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/admin/getdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_GetData(_response));
        });
    }

    protected processAdmin_GetData(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    admin_CheckAccess(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/admin/checkaccess";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CheckAccess(_response));
        });
    }

    protected processAdmin_CheckAccess(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    admin_CheckAccessPortal(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/admin/checkaccessportal";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CheckAccessPortal(_response));
        });
    }

    protected processAdmin_CheckAccessPortal(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    attachments_GetAttachments(attachmentType: AttachmentType, serviceType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<AttachmentDto[]> {
        let url_ = this.baseUrl + "/api/attachments/{attachmentType}?";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        if (serviceType !== undefined && serviceType !== null)
            url_ += "serviceType=" + encodeURIComponent("" + serviceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_GetAttachments(_response));
        });
    }

    protected processAttachments_GetAttachments(response: AxiosResponse): Promise<AttachmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentDto[]>(null as any);
    }

    attachments_AddAttachment(attachmentType: AttachmentType, serviceType: string | null | undefined, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/{attachmentType}?";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        if (serviceType !== undefined && serviceType !== null)
            url_ += "serviceType=" + encodeURIComponent("" + serviceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_AddAttachment(_response));
        });
    }

    protected processAttachments_AddAttachment(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_GetByListAttachmentType(listAttachmentType: AttachmentType[] , cancelToken?: CancelToken | undefined): Promise<AttachmentDto[]> {
        let url_ = this.baseUrl + "/api/attachments/getbylistattachmenttype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listAttachmentType);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_GetByListAttachmentType(_response));
        });
    }

    protected processAttachments_GetByListAttachmentType(response: AxiosResponse): Promise<AttachmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentDto[]>(null as any);
    }

    attachments_DeleteAttachments(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_DeleteAttachments(_response));
        });
    }

    protected processAttachments_DeleteAttachments(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_BulkDelete(items: string[] , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/bulkdeleteattachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_BulkDelete(_response));
        });
    }

    protected processAttachments_BulkDelete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_UpdateAttachmentInfo(updateDto: UpdateAttachmentInfoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/updateattachmentinfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_UpdateAttachmentInfo(_response));
        });
    }

    protected processAttachments_UpdateAttachmentInfo(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_AddAttachments(attachmentType: AttachmentType, serviceType: string | null | undefined, models: UploadFileModel[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result[]> {
        let url_ = this.baseUrl + "/api/attachments/multiples/{attachmentType}?";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        if (serviceType !== undefined && serviceType !== null)
            url_ += "serviceType=" + encodeURIComponent("" + serviceType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (models !== null && models !== undefined)
            models.forEach(item_ => content_.append("models", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_AddAttachments(_response));
        });
    }

    protected processAttachments_AddAttachments(response: AxiosResponse): Promise<Result[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Result.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Result[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result[]>(null as any);
    }

    commonConfig_GetCommonConfigByType(commonConfigType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<CommonConfigDto> {
        let url_ = this.baseUrl + "/api/commonconfig/getcommonconfigbytype?";
        if (commonConfigType !== undefined && commonConfigType !== null)
            url_ += "commonConfigType=" + encodeURIComponent("" + commonConfigType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonConfig_GetCommonConfigByType(_response));
        });
    }

    protected processCommonConfig_GetCommonConfigByType(response: AxiosResponse): Promise<CommonConfigDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommonConfigDto.fromJS(resultData200);
            return Promise.resolve<CommonConfigDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = CommonConfigDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommonConfigDto>(null as any);
    }

    commonConfig_SaveCommonConfig(createDto: CreateCommonConfigDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/commonconfig/savecommonconfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonConfig_SaveCommonConfig(_response));
        });
    }

    protected processCommonConfig_SaveCommonConfig(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CommonConfigDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    common_GetPortalLink(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/common/getportallink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommon_GetPortalLink(_response));
        });
    }

    protected processCommon_GetPortalLink(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    commonListInfo_GetAll(  cancelToken?: CancelToken | undefined): Promise<CommonListInfoDto[]> {
        let url_ = this.baseUrl + "/api/commonlistinfo/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonListInfo_GetAll(_response));
        });
    }

    protected processCommonListInfo_GetAll(response: AxiosResponse): Promise<CommonListInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonListInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CommonListInfoDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(CommonListInfoDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommonListInfoDto[]>(null as any);
    }

    commonListInfo_GetByType(type: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<CommonListInfoDto[]> {
        let url_ = this.baseUrl + "/api/commonlistinfo/getbytype?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonListInfo_GetByType(_response));
        });
    }

    protected processCommonListInfo_GetByType(response: AxiosResponse): Promise<CommonListInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonListInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CommonListInfoDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(CommonListInfoDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommonListInfoDto[]>(null as any);
    }

    commonListInfo_Create(model: CreateCommonListInfoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/commonlistinfo/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonListInfo_Create(_response));
        });
    }

    protected processCommonListInfo_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateCommonListInfoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    commonListInfo_Update(id: string, model: CreateCommonListInfoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/commonlistinfo/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonListInfo_Update(_response));
        });
    }

    protected processCommonListInfo_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateCommonListInfoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    commonListInfo_Delete(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/commonlistinfo/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonListInfo_Delete(_response));
        });
    }

    protected processCommonListInfo_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_GetContactCustomer(  cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto[]> {
        let url_ = this.baseUrl + "/api/contactcustomer/getallcontactcustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_GetContactCustomer(_response));
        });
    }

    protected processContactCustomer_GetContactCustomer(response: AxiosResponse): Promise<ContactCustomerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactCustomerDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto[]>(null as any);
    }

    contactCustomer_GetNew(id: string , cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto> {
        let url_ = this.baseUrl + "/api/contactcustomer/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_GetNew(_response));
        });
    }

    protected processContactCustomer_GetNew(response: AxiosResponse): Promise<ContactCustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContactCustomerDto.fromJS(resultData200);
            return Promise.resolve<ContactCustomerDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ContactCustomerDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto>(null as any);
    }

    contactCustomer_PutNew(id: string | undefined, model: CreateContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_PutNew(_response));
        });
    }

    protected processContactCustomer_PutNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ContactCustomerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_PostNew(model: CreateContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_PostNew(_response));
        });
    }

    protected processContactCustomer_PostNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ContactCustomerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_DeleteNew(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_DeleteNew(_response));
        });
    }

    protected processContactCustomer_DeleteNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_SearchingContactCustomer(model: SearchingContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto[]> {
        let url_ = this.baseUrl + "/api/contactcustomer/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_SearchingContactCustomer(_response));
        });
    }

    protected processContactCustomer_SearchingContactCustomer(response: AxiosResponse): Promise<ContactCustomerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactCustomerDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto[]>(null as any);
    }

    contactCustomer_UploadCV(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/contactcustomer/uploadcv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_UploadCV(_response));
        });
    }

    protected processContactCustomer_UploadCV(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    customerInformation_GetCustomerInformations(  cancelToken?: CancelToken | undefined): Promise<CustomerInformationDto[]> {
        let url_ = this.baseUrl + "/api/customerinformation/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerInformation_GetCustomerInformations(_response));
        });
    }

    protected processCustomerInformation_GetCustomerInformations(response: AxiosResponse): Promise<CustomerInformationDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerInformationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CustomerInformationDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerInformationDto[]>(null as any);
    }

    customerInformation_PostCustomerInformation(model: CreateCustomerInformationDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerinformation/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerInformation_PostCustomerInformation(_response));
        });
    }

    protected processCustomerInformation_PostCustomerInformation(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CustomerInformationDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    customerInformation_PutCustomerInformation(id: string | undefined, model: CreateCustomerInformationDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerinformation/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerInformation_PutCustomerInformation(_response));
        });
    }

    protected processCustomerInformation_PutCustomerInformation(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateCustomerInformationDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    customerInformation_DeleteCustomerInformation(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerinformation/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerInformation_DeleteCustomerInformation(_response));
        });
    }

    protected processCustomerInformation_DeleteCustomerInformation(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    customerReview_GetCustomerReviews(  cancelToken?: CancelToken | undefined): Promise<CustomerReviewDto[]> {
        let url_ = this.baseUrl + "/api/customerreview/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerReview_GetCustomerReviews(_response));
        });
    }

    protected processCustomerReview_GetCustomerReviews(response: AxiosResponse): Promise<CustomerReviewDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerReviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CustomerReviewDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerReviewDto[]>(null as any);
    }

    customerReview_PostCustomerReview(model: CreateCustomerReviewDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerreview/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerReview_PostCustomerReview(_response));
        });
    }

    protected processCustomerReview_PostCustomerReview(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CustomerReviewDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    customerReview_PutCustomerReview(id: string | undefined, model: CreateCustomerReviewDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerreview/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerReview_PutCustomerReview(_response));
        });
    }

    protected processCustomerReview_PutCustomerReview(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateCustomerReviewDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    customerReview_DeleteCustomerReview(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/customerreview/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomerReview_DeleteCustomerReview(_response));
        });
    }

    protected processCustomerReview_DeleteCustomerReview(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    health_Health(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processHealth_Health(_response));
        });
    }

    protected processHealth_Health(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    maintenanceRequest_Create(createDto: CreateMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_Create(_response));
        });
    }

    protected processMaintenanceRequest_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_Update(id: string, createDto: CreateMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_Update(_response));
        });
    }

    protected processMaintenanceRequest_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_GetByTenant(filterDto: MaintenanceRequestFilterDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfMaintenanceRequestDto> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getbytenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetByTenant(_response));
        });
    }

    protected processMaintenanceRequest_GetByTenant(response: AxiosResponse): Promise<PaginatedListOfMaintenanceRequestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(null as any);
    }

    maintenanceRequest_GetStatusByTenant(  cancelToken?: CancelToken | undefined): Promise<MaintenanceRequestStatusDto[]> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getstatusbytenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetStatusByTenant(_response));
        });
    }

    protected processMaintenanceRequest_GetStatusByTenant(response: AxiosResponse): Promise<MaintenanceRequestStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MaintenanceRequestStatusDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaintenanceRequestStatusDto[]>(null as any);
    }

    maintenanceRequest_GetByLandlord(filterDto: MaintenanceRequestFilterDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfMaintenanceRequestDto> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getbylandlord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetByLandlord(_response));
        });
    }

    protected processMaintenanceRequest_GetByLandlord(response: AxiosResponse): Promise<PaginatedListOfMaintenanceRequestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(null as any);
    }

    maintenanceRequest_GetStatusByLandlord(  cancelToken?: CancelToken | undefined): Promise<MaintenanceRequestStatusDto[]> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getstatusbylandlord";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetStatusByLandlord(_response));
        });
    }

    protected processMaintenanceRequest_GetStatusByLandlord(response: AxiosResponse): Promise<MaintenanceRequestStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MaintenanceRequestStatusDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaintenanceRequestStatusDto[]>(null as any);
    }

    maintenanceRequest_GetByAdmin(filterDto: MaintenanceRequestFilterDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfMaintenanceRequestDto> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getbyadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_GetByAdmin(response: AxiosResponse): Promise<PaginatedListOfMaintenanceRequestDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfMaintenanceRequestDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfMaintenanceRequestDto>(null as any);
    }

    maintenanceRequest_GetStatusByAdmin(  cancelToken?: CancelToken | undefined): Promise<MaintenanceRequestStatusDto[]> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getstatusbyadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetStatusByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_GetStatusByAdmin(response: AxiosResponse): Promise<MaintenanceRequestStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MaintenanceRequestStatusDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MaintenanceRequestStatusDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaintenanceRequestStatusDto[]>(null as any);
    }

    maintenanceRequest_ApproveByLandlord(approveDto: ApproveMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/approvebylandlord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(approveDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_ApproveByLandlord(_response));
        });
    }

    protected processMaintenanceRequest_ApproveByLandlord(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_ApproveByAdmin(approveDto: ApproveMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/approvebyadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(approveDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_ApproveByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_ApproveByAdmin(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_ProceedByAdmin(approveDto: ProceedMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/proceedbyadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(approveDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_ProceedByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_ProceedByAdmin(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_DoneByAdmin(approveDto: DoneMaintenanceRequestDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/maintenancerequest/donebyadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(approveDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_DoneByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_DoneByAdmin(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    maintenanceRequest_GetOperationByAdmin(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<MaintenanceRequestOperationInfoDto[]> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getoperationbyadmin?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetOperationByAdmin(_response));
        });
    }

    protected processMaintenanceRequest_GetOperationByAdmin(response: AxiosResponse): Promise<MaintenanceRequestOperationInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaintenanceRequestOperationInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MaintenanceRequestOperationInfoDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaintenanceRequestOperationInfoDto[]>(null as any);
    }

    maintenanceRequest_GetOperationByMaintenanceId(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<MaintenanceRequestOperationInfoDto[]> {
        let url_ = this.baseUrl + "/api/maintenancerequest/getoperationbymaintenanceid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMaintenanceRequest_GetOperationByMaintenanceId(_response));
        });
    }

    protected processMaintenanceRequest_GetOperationByMaintenanceId(response: AxiosResponse): Promise<MaintenanceRequestOperationInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaintenanceRequestOperationInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MaintenanceRequestOperationInfoDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaintenanceRequestOperationInfoDto[]>(null as any);
    }

    masterData_GetMasterDataByType(masterDataTypeId: string | undefined , cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatabytype?";
        if (masterDataTypeId === null)
            throw new Error("The parameter 'masterDataTypeId' cannot be null.");
        else if (masterDataTypeId !== undefined)
            url_ += "masterDataTypeId=" + encodeURIComponent("" + masterDataTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataByType(_response));
        });
    }

    protected processMasterData_GetMasterDataByType(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataPropertyType(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatapropertytype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataPropertyType(_response));
        });
    }

    protected processMasterData_GetMasterDataPropertyType(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataFeaturesCity(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatafeaturescity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataFeaturesCity(_response));
        });
    }

    protected processMasterData_GetMasterDataFeaturesCity(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataAmenitiesNearby(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdataamenitiesnearby";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataAmenitiesNearby(_response));
        });
    }

    protected processMasterData_GetMasterDataAmenitiesNearby(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataPriceRange(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatapricerange";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataPriceRange(_response));
        });
    }

    protected processMasterData_GetMasterDataPriceRange(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataAreaRange(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdataarearange";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataAreaRange(_response));
        });
    }

    protected processMasterData_GetMasterDataAreaRange(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataVideoCategory(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatavideocategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataVideoCategory(_response));
        });
    }

    protected processMasterData_GetMasterDataVideoCategory(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataMaintenanceArea(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdatamaintenancearea";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataMaintenanceArea(_response));
        });
    }

    protected processMasterData_GetMasterDataMaintenanceArea(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataErrorType(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdataerrortype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataErrorType(_response));
        });
    }

    protected processMasterData_GetMasterDataErrorType(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetMasterDataErrorDetails(  cancelToken?: CancelToken | undefined): Promise<MasterDataDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdataerrordetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterDataErrorDetails(_response));
        });
    }

    protected processMasterData_GetMasterDataErrorDetails(response: AxiosResponse): Promise<MasterDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataDto[]>(null as any);
    }

    masterData_GetAllMasterDataType(  cancelToken?: CancelToken | undefined): Promise<MasterDataTypeDto[]> {
        let url_ = this.baseUrl + "/api/masterdata/getallmasterdatatype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetAllMasterDataType(_response));
        });
    }

    protected processMasterData_GetAllMasterDataType(response: AxiosResponse): Promise<MasterDataTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterDataTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MasterDataTypeDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(MasterDataTypeDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MasterDataTypeDto[]>(null as any);
    }

    masterData_Create(createDto: CreateMasterDataDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/masterdata/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_Create(_response));
        });
    }

    protected processMasterData_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateMasterDataDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    masterData_Update(id: string, createDto: CreateMasterDataDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/masterdata/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_Update(_response));
        });
    }

    protected processMasterData_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateMasterDataDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    masterData_Delete(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/masterdata/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_Delete(_response));
        });
    }

    protected processMasterData_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_GetNewCategories(  cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto[]> {
        let url_ = this.baseUrl + "/api/newcategories/getallnewscategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategories(_response));
        });
    }

    protected processNewCategories_GetNewCategories(response: AxiosResponse): Promise<NewsCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto[]>(null as any);
    }

    newCategories_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto> {
        let url_ = this.baseUrl + "/api/newcategories/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategory(_response));
        });
    }

    protected processNewCategories_GetNewCategory(response: AxiosResponse): Promise<NewsCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryDto.fromJS(resultData200);
            return Promise.resolve<NewsCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto>(null as any);
    }

    newCategories_DetailsByFriendlyUrl(friendlyUrl: string | null , cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto> {
        let url_ = this.baseUrl + "/api/newcategories/detailsbyfriendlyurl/{friendlyUrl}";
        if (friendlyUrl === undefined || friendlyUrl === null)
            throw new Error("The parameter 'friendlyUrl' must be defined.");
        url_ = url_.replace("{friendlyUrl}", encodeURIComponent("" + friendlyUrl));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_DetailsByFriendlyUrl(_response));
        });
    }

    protected processNewCategories_DetailsByFriendlyUrl(response: AxiosResponse): Promise<NewsCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryDto.fromJS(resultData200);
            return Promise.resolve<NewsCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto>(null as any);
    }

    newCategories_PutNewCategory(id: string | undefined, model: CreateNewsCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_PutNewCategory(_response));
        });
    }

    protected processNewCategories_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNewsCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_PostNewCategory(model: CreateNewsCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_PostNewCategory(_response));
        });
    }

    protected processNewCategories_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_DeleteNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_DeleteNewCategory(_response));
        });
    }

    protected processNewCategories_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_GetNewCategoriesForAdmin(  cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto[]> {
        let url_ = this.baseUrl + "/api/newcategories/getallnewscategoryforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategoriesForAdmin(_response));
        });
    }

    protected processNewCategories_GetNewCategoriesForAdmin(response: AxiosResponse): Promise<NewsCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto[]>(null as any);
    }

    newCategories_GetNewCategoryForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto> {
        let url_ = this.baseUrl + "/api/newcategories/detailsforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategoryForAdmin(_response));
        });
    }

    protected processNewCategories_GetNewCategoryForAdmin(response: AxiosResponse): Promise<NewsCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryDto.fromJS(resultData200);
            return Promise.resolve<NewsCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto>(null as any);
    }

    news_GetNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getallnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNews(_response));
        });
    }

    protected processNews_GetNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetTopNews(number: number , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/top/{number}";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetTopNews(_response));
        });
    }

    protected processNews_GetTopNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetFeaturedNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getfeaturednews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetFeaturedNews(_response));
        });
    }

    protected processNews_GetFeaturedNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetHomeViewNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/gethomeviewnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetHomeViewNews(_response));
        });
    }

    protected processNews_GetHomeViewNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNormalNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getnormalnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNormalNews(_response));
        });
    }

    protected processNews_GetNormalNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNew(id: string , cancelToken?: CancelToken | undefined): Promise<NewsDto> {
        let url_ = this.baseUrl + "/api/news/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNew(_response));
        });
    }

    protected processNews_GetNew(response: AxiosResponse): Promise<NewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsDto.fromJS(resultData200);
            return Promise.resolve<NewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto>(null as any);
    }

    news_DetailByFriendlyUrl(friendlyUrl: string | null , cancelToken?: CancelToken | undefined): Promise<NewsDto> {
        let url_ = this.baseUrl + "/api/news/detailbyfriendlyurl/{friendlyUrl}";
        if (friendlyUrl === undefined || friendlyUrl === null)
            throw new Error("The parameter 'friendlyUrl' must be defined.");
        url_ = url_.replace("{friendlyUrl}", encodeURIComponent("" + friendlyUrl));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_DetailByFriendlyUrl(_response));
        });
    }

    protected processNews_DetailByFriendlyUrl(response: AxiosResponse): Promise<NewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsDto.fromJS(resultData200);
            return Promise.resolve<NewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto>(null as any);
    }

    news_Filter(filter: FilterNewsDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfNewsDto> {
        let url_ = this.baseUrl + "/api/news/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Filter(_response));
        });
    }

    protected processNews_Filter(response: AxiosResponse): Promise<PaginatedListOfNewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfNewsDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfNewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfNewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = FilterNewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfNewsDto>(null as any);
    }

    news_PutNew(id: string | undefined, model: CreateNewsDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_PutNew(_response));
        });
    }

    protected processNews_PutNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_Active(id: string | undefined, isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/active?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Active(_response));
        });
    }

    protected processNews_Active(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_PostNew(model: CreateNewsDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_PostNew(_response));
        });
    }

    protected processNews_PostNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_DeleteNew(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_DeleteNew(_response));
        });
    }

    protected processNews_DeleteNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_SearchingNews(model: SearchingNewsDto , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_SearchingNews(_response));
        });
    }

    protected processNews_SearchingNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(NewsDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetByCategoryNews(categoryId: string , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getnewsbycategory/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetByCategoryNews(_response));
        });
    }

    protected processNews_GetByCategoryNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNewForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<NewsDto> {
        let url_ = this.baseUrl + "/api/news/detailforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNewForAdmin(_response));
        });
    }

    protected processNews_GetNewForAdmin(response: AxiosResponse): Promise<NewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsDto.fromJS(resultData200);
            return Promise.resolve<NewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto>(null as any);
    }

    news_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/news/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_UploadImage(_response));
        });
    }

    protected processNews_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    photo_GetPhotos(  cancelToken?: CancelToken | undefined): Promise<PhotoDto[]> {
        let url_ = this.baseUrl + "/api/photo/getphotos";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetPhotos(_response));
        });
    }

    protected processPhoto_GetPhotos(response: AxiosResponse): Promise<PhotoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PhotoDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotoDto[]>(null as any);
    }

    photo_GetPhoto(id: string , cancelToken?: CancelToken | undefined): Promise<PhotoDto> {
        let url_ = this.baseUrl + "/api/photo/getphotos/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetPhoto(_response));
        });
    }

    protected processPhoto_GetPhoto(response: AxiosResponse): Promise<PhotoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PhotoDto.fromJS(resultData200);
            return Promise.resolve<PhotoDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PhotoDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotoDto>(null as any);
    }

    photo_PutPhoto(id: string, entity: PhotoDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/putphoto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PutPhoto(_response));
        });
    }

    protected processPhoto_PutPhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PhotoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_PostPhoto(model: PhotoDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/postphoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PostPhoto(_response));
        });
    }

    protected processPhoto_PostPhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PhotoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_DeletePhoto(id: string , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/deletephoto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_DeletePhoto(_response));
        });
    }

    protected processPhoto_DeletePhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/photo/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_UploadImage(_response));
        });
    }

    protected processPhoto_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    portal_GetMyProperty(filterDto: FilterMyPropertyDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfPropertyDto> {
        let url_ = this.baseUrl + "/api/portal/getmyproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetMyProperty(_response));
        });
    }

    protected processPortal_GetMyProperty(response: AxiosResponse): Promise<PaginatedListOfPropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfPropertyDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfPropertyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfPropertyDto>(null as any);
    }

    portal_GetMyPropertyById(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyDto> {
        let url_ = this.baseUrl + "/api/portal/getmypropertybyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetMyPropertyById(_response));
        });
    }

    protected processPortal_GetMyPropertyById(response: AxiosResponse): Promise<PropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyDto.fromJS(resultData200);
            return Promise.resolve<PropertyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyDto>(null as any);
    }

    portal_GetMyPropertyHistory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyHistoryDto[]> {
        let url_ = this.baseUrl + "/api/portal/getmypropertyhistory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetMyPropertyHistory(_response));
        });
    }

    protected processPortal_GetMyPropertyHistory(response: AxiosResponse): Promise<PropertyHistoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyHistoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyHistoryDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(PropertyHistoryDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyHistoryDto[]>(null as any);
    }

    portal_GetPropertyStatus(  cancelToken?: CancelToken | undefined): Promise<PropertyStatusDto[]> {
        let url_ = this.baseUrl + "/api/portal/getmypropertystatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetPropertyStatus(_response));
        });
    }

    protected processPortal_GetPropertyStatus(response: AxiosResponse): Promise<PropertyStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyStatusDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyStatusDto[]>(null as any);
    }

    portal_GetLeasingPropertyStatus(  cancelToken?: CancelToken | undefined): Promise<PropertyStatusDto[]> {
        let url_ = this.baseUrl + "/api/portal/getleasingpropertystatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetLeasingPropertyStatus(_response));
        });
    }

    protected processPortal_GetLeasingPropertyStatus(response: AxiosResponse): Promise<PropertyStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyStatusDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyStatusDto[]>(null as any);
    }

    portal_GetLeasingProperty(filterDto: FilterMyPropertyDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfPropertyDto> {
        let url_ = this.baseUrl + "/api/portal/getleasingproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetLeasingProperty(_response));
        });
    }

    protected processPortal_GetLeasingProperty(response: AxiosResponse): Promise<PaginatedListOfPropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfPropertyDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfPropertyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfPropertyDto>(null as any);
    }

    portal_GetLeasingPropertyById(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyDto> {
        let url_ = this.baseUrl + "/api/portal/getleasingpropertybyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetLeasingPropertyById(_response));
        });
    }

    protected processPortal_GetLeasingPropertyById(response: AxiosResponse): Promise<PropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyDto.fromJS(resultData200);
            return Promise.resolve<PropertyDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyDto>(null as any);
    }

    portal_GetRoles(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/portal/getroles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPortal_GetRoles(_response));
        });
    }

    protected processPortal_GetRoles(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    project_GetAll(  cancelToken?: CancelToken | undefined): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/project/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_GetAll(_response));
        });
    }

    protected processProject_GetAll(response: AxiosResponse): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProjectDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ProjectDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectDto[]>(null as any);
    }

    project_GetDetail(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<ProjectDto> {
        let url_ = this.baseUrl + "/api/project/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_GetDetail(_response));
        });
    }

    protected processProject_GetDetail(response: AxiosResponse): Promise<ProjectDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectDto.fromJS(resultData200);
            return Promise.resolve<ProjectDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProjectDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectDto>(null as any);
    }

    project_DetailByFriendlyUrl(friendlyUrl: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ProjectDto> {
        let url_ = this.baseUrl + "/api/project/getbyfriendlyurl?";
        if (friendlyUrl !== undefined && friendlyUrl !== null)
            url_ += "friendlyUrl=" + encodeURIComponent("" + friendlyUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_DetailByFriendlyUrl(_response));
        });
    }

    protected processProject_DetailByFriendlyUrl(response: AxiosResponse): Promise<ProjectDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectDto.fromJS(resultData200);
            return Promise.resolve<ProjectDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProjectDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectDto>(null as any);
    }

    project_Update(id: string, model: CreateProjectDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Update(_response));
        });
    }

    protected processProject_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateProjectDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_Create(model: CreateProjectDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Create(_response));
        });
    }

    protected processProject_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateProjectDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_Delete(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Delete(_response));
        });
    }

    protected processProject_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_Filter(filter: ProjectFilterDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProjectDto> {
        let url_ = this.baseUrl + "/api/project/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Filter(_response));
        });
    }

    protected processProject_Filter(response: AxiosResponse): Promise<PaginatedListOfProjectDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProjectDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProjectDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfProjectDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProjectDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProjectDto>(null as any);
    }

    projectType_GetAll(  cancelToken?: CancelToken | undefined): Promise<ProjectTypeDto[]> {
        let url_ = this.baseUrl + "/api/projecttype/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_GetAll(_response));
        });
    }

    protected processProjectType_GetAll(response: AxiosResponse): Promise<ProjectTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProjectTypeDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ProjectTypeDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeDto[]>(null as any);
    }

    projectType_GetDetail(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<ProjectTypeDto> {
        let url_ = this.baseUrl + "/api/projecttype/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_GetDetail(_response));
        });
    }

    protected processProjectType_GetDetail(response: AxiosResponse): Promise<ProjectTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectTypeDto.fromJS(resultData200);
            return Promise.resolve<ProjectTypeDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProjectTypeDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeDto>(null as any);
    }

    projectType_DetailByFriendlyUrl(friendlyUrl: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<ProjectTypeDto> {
        let url_ = this.baseUrl + "/api/projecttype/getbyfriendlyurl?";
        if (friendlyUrl !== undefined && friendlyUrl !== null)
            url_ += "friendlyUrl=" + encodeURIComponent("" + friendlyUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_DetailByFriendlyUrl(_response));
        });
    }

    protected processProjectType_DetailByFriendlyUrl(response: AxiosResponse): Promise<ProjectTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectTypeDto.fromJS(resultData200);
            return Promise.resolve<ProjectTypeDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProjectTypeDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeDto>(null as any);
    }

    projectType_Update(id: string, model: CreateProjectTypeDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/projecttype/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_Update(_response));
        });
    }

    protected processProjectType_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateProjectTypeDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    projectType_Create(model: CreateProjectTypeDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/projecttype/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_Create(_response));
        });
    }

    protected processProjectType_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateProjectTypeDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    projectType_Delete(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/projecttype/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectType_Delete(_response));
        });
    }

    protected processProjectType_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_GetAll(  cancelToken?: CancelToken | undefined): Promise<PropertyDto[]> {
        let url_ = this.baseUrl + "/api/property/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetAll(_response));
        });
    }

    protected processProperty_GetAll(response: AxiosResponse): Promise<PropertyDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(PropertyDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyDto[]>(null as any);
    }

    property_GetPaging(pageNumber: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfPropertyDto> {
        let url_ = this.baseUrl + "/api/property/getpaging?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetPaging(_response));
        });
    }

    protected processProperty_GetPaging(response: AxiosResponse): Promise<PaginatedListOfPropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfPropertyDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfPropertyDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfPropertyDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfPropertyDto>(null as any);
    }

    property_GetDetail(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyDto> {
        let url_ = this.baseUrl + "/api/property/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetDetail(_response));
        });
    }

    protected processProperty_GetDetail(response: AxiosResponse): Promise<PropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyDto.fromJS(resultData200);
            return Promise.resolve<PropertyDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PropertyDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyDto>(null as any);
    }

    property_GetPropertyHistoryByPropertyId(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyHistoryDto[]> {
        let url_ = this.baseUrl + "/api/property/getpropertyhistorybypropertyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetPropertyHistoryByPropertyId(_response));
        });
    }

    protected processProperty_GetPropertyHistoryByPropertyId(response: AxiosResponse): Promise<PropertyHistoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyHistoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyHistoryDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(PropertyHistoryDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyHistoryDto[]>(null as any);
    }

    property_DetailByFriendlyUrl(friendlyUrl: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyDto> {
        let url_ = this.baseUrl + "/api/property/getbyfriendlyurl?";
        if (friendlyUrl !== undefined && friendlyUrl !== null)
            url_ += "friendlyUrl=" + encodeURIComponent("" + friendlyUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_DetailByFriendlyUrl(_response));
        });
    }

    protected processProperty_DetailByFriendlyUrl(response: AxiosResponse): Promise<PropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyDto.fromJS(resultData200);
            return Promise.resolve<PropertyDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PropertyDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyDto>(null as any);
    }

    property_Create(model: CreatePropertyDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Create(_response));
        });
    }

    protected processProperty_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_Update(id: string, model: CreatePropertyDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Update(_response));
        });
    }

    protected processProperty_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_AddLandlordProperty(createDto: CreateLandlordDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/addlandlordproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_AddLandlordProperty(_response));
        });
    }

    protected processProperty_AddLandlordProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_ChangeLandlordProperty(createDto: CreateLandlordDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/changelandlordproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_ChangeLandlordProperty(_response));
        });
    }

    protected processProperty_ChangeLandlordProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_AddTenantProperty(createDto: CreateTenantDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/addtenantproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_AddTenantProperty(_response));
        });
    }

    protected processProperty_AddTenantProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_RemoveTenantProperty(createDto: CreateTenantDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/removetenantproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_RemoveTenantProperty(_response));
        });
    }

    protected processProperty_RemoveTenantProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_UseVerifyCode(createDto: UseVerifyCodeDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/useverifycode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_UseVerifyCode(_response));
        });
    }

    protected processProperty_UseVerifyCode(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_Filter(filter: PropertyFilterDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfPropertyDto> {
        let url_ = this.baseUrl + "/api/property/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Filter(_response));
        });
    }

    protected processProperty_Filter(response: AxiosResponse): Promise<PaginatedListOfPropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfPropertyDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfPropertyDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfPropertyDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfPropertyDto>(null as any);
    }

    socialNetwork_GetSocialNetworks(  cancelToken?: CancelToken | undefined): Promise<SocialNetworkDto[]> {
        let url_ = this.baseUrl + "/api/socialnetwork/getallsocialnetwork";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_GetSocialNetworks(_response));
        });
    }

    protected processSocialNetwork_GetSocialNetworks(response: AxiosResponse): Promise<SocialNetworkDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialNetworkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SocialNetworkDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkDto[]>(null as any);
    }

    socialNetwork_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<SocialNetworkDto> {
        let url_ = this.baseUrl + "/api/socialnetwork/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_GetNewCategory(_response));
        });
    }

    protected processSocialNetwork_GetNewCategory(response: AxiosResponse): Promise<SocialNetworkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SocialNetworkDto.fromJS(resultData200);
            return Promise.resolve<SocialNetworkDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = SocialNetworkDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkDto>(null as any);
    }

    socialNetwork_PutNewCategory(id: string | undefined, model: CreateSocialNetworkDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_PutNewCategory(_response));
        });
    }

    protected processSocialNetwork_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateSocialNetworkDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_PostNewCategory(model: CreateSocialNetworkDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_PostNewCategory(_response));
        });
    }

    protected processSocialNetwork_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = SocialNetworkDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_DeleteNewCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_DeleteNewCategory(_response));
        });
    }

    protected processSocialNetwork_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetworkType_GetAllSocialNetworkType(  cancelToken?: CancelToken | undefined): Promise<SocialNetworkTypeDto[]> {
        let url_ = this.baseUrl + "/api/socialnetworktype/getallsocialnetworktype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetworkType_GetAllSocialNetworkType(_response));
        });
    }

    protected processSocialNetworkType_GetAllSocialNetworkType(response: AxiosResponse): Promise<SocialNetworkTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialNetworkTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SocialNetworkTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkTypeDto[]>(null as any);
    }

    user_SearchUserByEmail(email: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UserInfo[]> {
        let url_ = this.baseUrl + "/api/user/searchuserbyemail?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_SearchUserByEmail(_response));
        });
    }

    protected processUser_SearchUserByEmail(response: AxiosResponse): Promise<UserInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfo[]>(null as any);
    }

    video_GetAll(  cancelToken?: CancelToken | undefined): Promise<VideoDto[]> {
        let url_ = this.baseUrl + "/api/video/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_GetAll(_response));
        });
    }

    protected processVideo_GetAll(response: AxiosResponse): Promise<VideoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VideoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<VideoDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(VideoDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoDto[]>(null as any);
    }

    video_GetByCategory(catergoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<VideoDto[]> {
        let url_ = this.baseUrl + "/api/video/getbycategory?";
        if (catergoryId === null)
            throw new Error("The parameter 'catergoryId' cannot be null.");
        else if (catergoryId !== undefined)
            url_ += "catergoryId=" + encodeURIComponent("" + catergoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_GetByCategory(_response));
        });
    }

    protected processVideo_GetByCategory(response: AxiosResponse): Promise<VideoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VideoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<VideoDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(VideoDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VideoDto[]>(null as any);
    }

    video_GetFilterWebsite(filterDto: FilterVideoDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfVideoDto> {
        let url_ = this.baseUrl + "/api/video/getfilterwebsite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_GetFilterWebsite(_response));
        });
    }

    protected processVideo_GetFilterWebsite(response: AxiosResponse): Promise<PaginatedListOfVideoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfVideoDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfVideoDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfVideoDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfVideoDto>(null as any);
    }

    video_Create(createDto: CreateVideoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/video/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_Create(_response));
        });
    }

    protected processVideo_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateVideoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    video_Update(id: string, createDto: CreateVideoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/video/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_Update(_response));
        });
    }

    protected processVideo_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateVideoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    video_Delete(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/video/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVideo_Delete(_response));
        });
    }

    protected processVideo_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    website_GetHomeInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/gethomeinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetHomeInfo(_response));
        });
    }

    protected processWebsite_GetHomeInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetContactInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getcontactinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetContactInfo(_response));
        });
    }

    protected processWebsite_GetContactInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetFooterInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getfooterinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetFooterInfo(_response));
        });
    }

    protected processWebsite_GetFooterInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetAboutUsInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getaboutusinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetAboutUsInfo(_response));
        });
    }

    protected processWebsite_GetAboutUsInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetVideoInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getvideoinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetVideoInfo(_response));
        });
    }

    protected processWebsite_GetVideoInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetNewsInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getnewsinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetNewsInfo(_response));
        });
    }

    protected processWebsite_GetNewsInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetBannerHomePage(  cancelToken?: CancelToken | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/website/getbannerhomepage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetBannerHomePage(_response));
        });
    }

    protected processWebsite_GetBannerHomePage(response: AxiosResponse): Promise<any[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<any[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any[]>(null as any);
    }

    website_GetOurCommitment(  cancelToken?: CancelToken | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/website/getourcommitment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetOurCommitment(_response));
        });
    }

    protected processWebsite_GetOurCommitment(response: AxiosResponse): Promise<any[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<any[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any[]>(null as any);
    }

    website_GetOurServices(  cancelToken?: CancelToken | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/website/getourservices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetOurServices(_response));
        });
    }

    protected processWebsite_GetOurServices(response: AxiosResponse): Promise<any[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<any[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any[]>(null as any);
    }

    website_GetOurTeams(  cancelToken?: CancelToken | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/website/getourteams";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetOurTeams(_response));
        });
    }

    protected processWebsite_GetOurTeams(response: AxiosResponse): Promise<any[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<any[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any[]>(null as any);
    }

    website_GetOurPartners(  cancelToken?: CancelToken | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/website/getourpartners";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetOurPartners(_response));
        });
    }

    protected processWebsite_GetOurPartners(response: AxiosResponse): Promise<any[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<any[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any[]>(null as any);
    }

    website_GetTenantPortalInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/gettenantportalinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetTenantPortalInfo(_response));
        });
    }

    protected processWebsite_GetTenantPortalInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_GetLandlordPortalInfo(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/website/getlandlordportalinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_GetLandlordPortalInfo(_response));
        });
    }

    protected processWebsite_GetLandlordPortalInfo(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    website_FilterProperty(filter: FilterWebsitePropertyDto , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfPropertyDto> {
        let url_ = this.baseUrl + "/api/website/filterproperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsite_FilterProperty(_response));
        });
    }

    protected processWebsite_FilterProperty(response: AxiosResponse): Promise<PaginatedListOfPropertyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfPropertyDto.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfPropertyDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PaginatedListOfPropertyDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PropertyDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfPropertyDto>(null as any);
    }
}

export class AttachmentDto implements IAttachmentDto {
    id?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    fileSizeInKb?: number;
    fileSizeInMb?: number;
    created?: Date;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
    attachmentType?: AttachmentType;
    serviceType?: string | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.filePath = _data["filePath"];
            this.fileUrl = _data["fileUrl"];
            this.fileSize = _data["fileSize"];
            this.fileSizeInKb = _data["fileSizeInKb"];
            this.fileSizeInMb = _data["fileSizeInMb"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.caption1 = _data["caption1"];
            this.caption2 = _data["caption2"];
            this.note = _data["note"];
            this.ordinal = _data["ordinal"];
            this.attachmentType = _data["attachmentType"];
            this.serviceType = _data["serviceType"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["filePath"] = this.filePath;
        data["fileUrl"] = this.fileUrl;
        data["fileSize"] = this.fileSize;
        data["fileSizeInKb"] = this.fileSizeInKb;
        data["fileSizeInMb"] = this.fileSizeInMb;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["caption1"] = this.caption1;
        data["caption2"] = this.caption2;
        data["note"] = this.note;
        data["ordinal"] = this.ordinal;
        data["attachmentType"] = this.attachmentType;
        data["serviceType"] = this.serviceType;
        return data;
    }
}

export interface IAttachmentDto {
    id?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    fileSizeInKb?: number;
    fileSizeInMb?: number;
    created?: Date;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
    attachmentType?: AttachmentType;
    serviceType?: string | undefined;
}

export enum AttachmentType {
    All = 0,
    Photo = 1,
    Video = 2,
    Excel = 3,
    Audio = 4,
    File3D = 5,
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.objectReturn = _data["objectReturn"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["objectReturn"] = this.objectReturn;
        return data;
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;
}

export class UpdateAttachmentInfoDto implements IUpdateAttachmentInfoDto {
    id?: string;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;

    constructor(data?: IUpdateAttachmentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caption1 = _data["caption1"];
            this.caption2 = _data["caption2"];
            this.note = _data["note"];
            this.ordinal = _data["ordinal"];
        }
    }

    static fromJS(data: any): UpdateAttachmentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttachmentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caption1"] = this.caption1;
        data["caption2"] = this.caption2;
        data["note"] = this.note;
        data["ordinal"] = this.ordinal;
        return data;
    }
}

export interface IUpdateAttachmentInfoDto {
    id?: string;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
}

export class UploadFileModel implements IUploadFileModel {
    file?: string | undefined;

    constructor(data?: IUploadFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UploadFileModel {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data;
    }
}

export interface IUploadFileModel {
    file?: string | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isDeleted?: DeletedStatus;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isDeleted?: DeletedStatus;
}

export class CommonConfigDto extends AuditableEntity implements ICommonConfigDto {
    id?: string;
    commonConfigType?: string | undefined;
    data?: any | undefined;

    constructor(data?: ICommonConfigDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.commonConfigType = _data["commonConfigType"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CommonConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commonConfigType"] = this.commonConfigType;
        data["data"] = this.data;
        super.toJSON(data);
        return data;
    }
}

export interface ICommonConfigDto extends IAuditableEntity {
    id?: string;
    commonConfigType?: string | undefined;
    data?: any | undefined;
}

export enum DeletedStatus {
    False = 1,
    True = 2,
}

export class CreateCommonConfigDto extends AuditableEntity implements ICreateCommonConfigDto {
    commonConfigType?: string | undefined;
    data?: any | undefined;
    listRemoveFilePath?: string[] | undefined;

    constructor(data?: ICreateCommonConfigDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commonConfigType = _data["commonConfigType"];
            this.data = _data["data"];
            if (Array.isArray(_data["listRemoveFilePath"])) {
                this.listRemoveFilePath = [] as any;
                for (let item of _data["listRemoveFilePath"])
                    this.listRemoveFilePath!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCommonConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommonConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commonConfigType"] = this.commonConfigType;
        data["data"] = this.data;
        if (Array.isArray(this.listRemoveFilePath)) {
            data["listRemoveFilePath"] = [];
            for (let item of this.listRemoveFilePath)
                data["listRemoveFilePath"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCommonConfigDto extends IAuditableEntity {
    commonConfigType?: string | undefined;
    data?: any | undefined;
    listRemoveFilePath?: string[] | undefined;
}

export class CommonListInfoDto implements ICommonListInfoDto {
    id?: string;
    type?: string | undefined;
    privateType?: string | undefined;
    isActive?: boolean;
    fileFields?: string | undefined;
    data?: any | undefined;

    constructor(data?: ICommonListInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.privateType = _data["privateType"];
            this.isActive = _data["isActive"];
            this.fileFields = _data["fileFields"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CommonListInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonListInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["privateType"] = this.privateType;
        data["isActive"] = this.isActive;
        data["fileFields"] = this.fileFields;
        data["data"] = this.data;
        return data;
    }
}

export interface ICommonListInfoDto {
    id?: string;
    type?: string | undefined;
    privateType?: string | undefined;
    isActive?: boolean;
    fileFields?: string | undefined;
    data?: any | undefined;
}

export class CreateCommonListInfoDto implements ICreateCommonListInfoDto {
    type?: string | undefined;
    privateType?: string | undefined;
    isActive?: boolean;
    fileFields?: string[] | undefined;
    data?: any | undefined;

    constructor(data?: ICreateCommonListInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.privateType = _data["privateType"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["fileFields"])) {
                this.fileFields = [] as any;
                for (let item of _data["fileFields"])
                    this.fileFields!.push(item);
            }
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CreateCommonListInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommonListInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["privateType"] = this.privateType;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.fileFields)) {
            data["fileFields"] = [];
            for (let item of this.fileFields)
                data["fileFields"].push(item);
        }
        data["data"] = this.data;
        return data;
    }
}

export interface ICreateCommonListInfoDto {
    type?: string | undefined;
    privateType?: string | undefined;
    isActive?: boolean;
    fileFields?: string[] | undefined;
    data?: any | undefined;
}

export class ContactCustomerDto extends AuditableEntity implements IContactCustomerDto {
    id?: string;
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;

    constructor(data?: IContactCustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerEmail = _data["customerEmail"];
            this.content = _data["content"];
            this.attachFile = _data["attachFile"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): ContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerEmail"] = this.customerEmail;
        data["content"] = this.content;
        data["attachFile"] = this.attachFile;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        super.toJSON(data);
        return data;
    }
}

export interface IContactCustomerDto extends IAuditableEntity {
    id?: string;
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;
}

export enum ContactTypesEnum {
    Contact = 1,
    Recruitment = 2,
    Order = 3,
}

export class CreateContactCustomerDto implements ICreateContactCustomerDto {
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    customerAddress?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;

    constructor(data?: ICreateContactCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerEmail = _data["customerEmail"];
            this.content = _data["content"];
            this.attachFile = _data["attachFile"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): CreateContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerEmail"] = this.customerEmail;
        data["content"] = this.content;
        data["attachFile"] = this.attachFile;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ICreateContactCustomerDto {
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;
}

export class SearchingContactCustomerDto implements ISearchingContactCustomerDto {
    name?: string | undefined;
    receiveStatus?: boolean | undefined;
    contactType?: ContactTypesEnum | undefined;

    constructor(data?: ISearchingContactCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): SearchingContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ISearchingContactCustomerDto {
    name?: string | undefined;
    receiveStatus?: boolean | undefined;
    contactType?: ContactTypesEnum | undefined;
}

export class CustomerInformationDto implements ICustomerInformationDto {
    id?: string;
    customerName?: string | undefined;
    customerNameEn?: string | undefined;
    order?: number;
    actionLink?: string | undefined;
    description?: string | undefined;
    descriptionEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;

    constructor(data?: ICustomerInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerName = _data["customerName"];
            this.customerNameEn = _data["customerNameEn"];
            this.order = _data["order"];
            this.actionLink = _data["actionLink"];
            this.description = _data["description"];
            this.descriptionEn = _data["descriptionEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["customerNameEn"] = this.customerNameEn;
        data["order"] = this.order;
        data["actionLink"] = this.actionLink;
        data["description"] = this.description;
        data["descriptionEn"] = this.descriptionEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomerInformationDto {
    id?: string;
    customerName?: string | undefined;
    customerNameEn?: string | undefined;
    order?: number;
    actionLink?: string | undefined;
    description?: string | undefined;
    descriptionEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;
}

export class CreateCustomerInformationDto implements ICreateCustomerInformationDto {
    customerName?: string | undefined;
    customerNameEn?: string | undefined;
    order?: number;
    actionLink?: string | undefined;
    description?: string | undefined;
    descriptionEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: ICreateCustomerInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            this.customerNameEn = _data["customerNameEn"];
            this.order = _data["order"];
            this.actionLink = _data["actionLink"];
            this.description = _data["description"];
            this.descriptionEn = _data["descriptionEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): CreateCustomerInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["customerNameEn"] = this.customerNameEn;
        data["order"] = this.order;
        data["actionLink"] = this.actionLink;
        data["description"] = this.description;
        data["descriptionEn"] = this.descriptionEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface ICreateCustomerInformationDto {
    customerName?: string | undefined;
    customerNameEn?: string | undefined;
    order?: number;
    actionLink?: string | undefined;
    description?: string | undefined;
    descriptionEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
}

export class CustomerReviewDto implements ICustomerReviewDto {
    id?: string;
    title?: string | undefined;
    titleEn?: string | undefined;
    subTitle?: string | undefined;
    subTitleEn?: string | undefined;
    customerName?: string | undefined;
    company?: string | undefined;
    rating?: number | undefined;
    order?: number | undefined;
    comment?: string | undefined;
    commentEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;

    constructor(data?: ICustomerReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.titleEn = _data["titleEn"];
            this.subTitle = _data["subTitle"];
            this.subTitleEn = _data["subTitleEn"];
            this.customerName = _data["customerName"];
            this.company = _data["company"];
            this.rating = _data["rating"];
            this.order = _data["order"];
            this.comment = _data["comment"];
            this.commentEn = _data["commentEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["titleEn"] = this.titleEn;
        data["subTitle"] = this.subTitle;
        data["subTitleEn"] = this.subTitleEn;
        data["customerName"] = this.customerName;
        data["company"] = this.company;
        data["rating"] = this.rating;
        data["order"] = this.order;
        data["comment"] = this.comment;
        data["commentEn"] = this.commentEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomerReviewDto {
    id?: string;
    title?: string | undefined;
    titleEn?: string | undefined;
    subTitle?: string | undefined;
    subTitleEn?: string | undefined;
    customerName?: string | undefined;
    company?: string | undefined;
    rating?: number | undefined;
    order?: number | undefined;
    comment?: string | undefined;
    commentEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;
}

export class CreateCustomerReviewDto implements ICreateCustomerReviewDto {
    title?: string | undefined;
    titleEn?: string | undefined;
    subTitle?: string | undefined;
    subTitleEn?: string | undefined;
    customerName?: string | undefined;
    company?: string | undefined;
    rating?: number | undefined;
    order?: number | undefined;
    comment?: string | undefined;
    commentEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: ICreateCustomerReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.titleEn = _data["titleEn"];
            this.subTitle = _data["subTitle"];
            this.subTitleEn = _data["subTitleEn"];
            this.customerName = _data["customerName"];
            this.company = _data["company"];
            this.rating = _data["rating"];
            this.order = _data["order"];
            this.comment = _data["comment"];
            this.commentEn = _data["commentEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): CreateCustomerReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["titleEn"] = this.titleEn;
        data["subTitle"] = this.subTitle;
        data["subTitleEn"] = this.subTitleEn;
        data["customerName"] = this.customerName;
        data["company"] = this.company;
        data["rating"] = this.rating;
        data["order"] = this.order;
        data["comment"] = this.comment;
        data["commentEn"] = this.commentEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface ICreateCustomerReviewDto {
    title?: string | undefined;
    titleEn?: string | undefined;
    subTitle?: string | undefined;
    subTitleEn?: string | undefined;
    customerName?: string | undefined;
    company?: string | undefined;
    rating?: number | undefined;
    order?: number | undefined;
    comment?: string | undefined;
    commentEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
}

export class CreatePropertyDto implements ICreatePropertyDto {
    code?: string | undefined;
    title?: string | undefined;
    location?: string | undefined;
    transactionType?: PropertyTransactionType;
    propertyTypeId?: string | undefined;
    propertyType?: MasterDataDto | undefined;
    featuresCityId?: string | undefined;
    featuresCity?: MasterDataDto | undefined;
    isActive?: boolean;
    isFeatures?: boolean;
    status?: PropertyStatus | undefined;
    price?: number;
    hostInformation?: string | undefined;
    lotSize?: number;
    bathrooms?: number;
    bedrooms?: number;
    livingrooms?: number;
    balconies?: number;
    carParking?: number;
    totalFloors?: number;
    gagares?: number;
    kitchens?: number;
    pools?: number;
    insurance?: boolean;
    constructionYear?: Date | undefined;
    tags?: string | undefined;
    videoLink?: string | undefined;
    videoLinkProcess?: string | undefined;
    mapLink?: string | undefined;
    mapLinkProcess?: string | undefined;
    shortDescriptions?: string | undefined;
    descriptions?: string | undefined;
    listPropertyAmenities?: PropertyAmenitiesDto[] | undefined;
    listPropertyImage?: PropertyImageDto[] | undefined;

    constructor(data?: ICreatePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.title = _data["title"];
            this.location = _data["location"];
            this.transactionType = _data["transactionType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyType = _data["propertyType"] ? MasterDataDto.fromJS(_data["propertyType"]) : <any>undefined;
            this.featuresCityId = _data["featuresCityId"];
            this.featuresCity = _data["featuresCity"] ? MasterDataDto.fromJS(_data["featuresCity"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isFeatures = _data["isFeatures"];
            this.status = _data["status"];
            this.price = _data["price"];
            this.hostInformation = _data["hostInformation"];
            this.lotSize = _data["lotSize"];
            this.bathrooms = _data["bathrooms"];
            this.bedrooms = _data["bedrooms"];
            this.livingrooms = _data["livingrooms"];
            this.balconies = _data["balconies"];
            this.carParking = _data["carParking"];
            this.totalFloors = _data["totalFloors"];
            this.gagares = _data["gagares"];
            this.kitchens = _data["kitchens"];
            this.pools = _data["pools"];
            this.insurance = _data["insurance"];
            this.constructionYear = _data["constructionYear"] ? new Date(_data["constructionYear"].toString()) : <any>undefined;
            this.tags = _data["tags"];
            this.videoLink = _data["videoLink"];
            this.videoLinkProcess = _data["videoLinkProcess"];
            this.mapLink = _data["mapLink"];
            this.mapLinkProcess = _data["mapLinkProcess"];
            this.shortDescriptions = _data["shortDescriptions"];
            this.descriptions = _data["descriptions"];
            if (Array.isArray(_data["listPropertyAmenities"])) {
                this.listPropertyAmenities = [] as any;
                for (let item of _data["listPropertyAmenities"])
                    this.listPropertyAmenities!.push(PropertyAmenitiesDto.fromJS(item));
            }
            if (Array.isArray(_data["listPropertyImage"])) {
                this.listPropertyImage = [] as any;
                for (let item of _data["listPropertyImage"])
                    this.listPropertyImage!.push(PropertyImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["title"] = this.title;
        data["location"] = this.location;
        data["transactionType"] = this.transactionType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["featuresCityId"] = this.featuresCityId;
        data["featuresCity"] = this.featuresCity ? this.featuresCity.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isFeatures"] = this.isFeatures;
        data["status"] = this.status;
        data["price"] = this.price;
        data["hostInformation"] = this.hostInformation;
        data["lotSize"] = this.lotSize;
        data["bathrooms"] = this.bathrooms;
        data["bedrooms"] = this.bedrooms;
        data["livingrooms"] = this.livingrooms;
        data["balconies"] = this.balconies;
        data["carParking"] = this.carParking;
        data["totalFloors"] = this.totalFloors;
        data["gagares"] = this.gagares;
        data["kitchens"] = this.kitchens;
        data["pools"] = this.pools;
        data["insurance"] = this.insurance;
        data["constructionYear"] = this.constructionYear ? this.constructionYear.toISOString() : <any>undefined;
        data["tags"] = this.tags;
        data["videoLink"] = this.videoLink;
        data["videoLinkProcess"] = this.videoLinkProcess;
        data["mapLink"] = this.mapLink;
        data["mapLinkProcess"] = this.mapLinkProcess;
        data["shortDescriptions"] = this.shortDescriptions;
        data["descriptions"] = this.descriptions;
        if (Array.isArray(this.listPropertyAmenities)) {
            data["listPropertyAmenities"] = [];
            for (let item of this.listPropertyAmenities)
                data["listPropertyAmenities"].push(item.toJSON());
        }
        if (Array.isArray(this.listPropertyImage)) {
            data["listPropertyImage"] = [];
            for (let item of this.listPropertyImage)
                data["listPropertyImage"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePropertyDto {
    code?: string | undefined;
    title?: string | undefined;
    location?: string | undefined;
    transactionType?: PropertyTransactionType;
    propertyTypeId?: string | undefined;
    propertyType?: MasterDataDto | undefined;
    featuresCityId?: string | undefined;
    featuresCity?: MasterDataDto | undefined;
    isActive?: boolean;
    isFeatures?: boolean;
    status?: PropertyStatus | undefined;
    price?: number;
    hostInformation?: string | undefined;
    lotSize?: number;
    bathrooms?: number;
    bedrooms?: number;
    livingrooms?: number;
    balconies?: number;
    carParking?: number;
    totalFloors?: number;
    gagares?: number;
    kitchens?: number;
    pools?: number;
    insurance?: boolean;
    constructionYear?: Date | undefined;
    tags?: string | undefined;
    videoLink?: string | undefined;
    videoLinkProcess?: string | undefined;
    mapLink?: string | undefined;
    mapLinkProcess?: string | undefined;
    shortDescriptions?: string | undefined;
    descriptions?: string | undefined;
    listPropertyAmenities?: PropertyAmenitiesDto[] | undefined;
    listPropertyImage?: PropertyImageDto[] | undefined;
}

export enum PropertyTransactionType {
    All = 0,
    Rent = 1,
    Sale = 2,
}

export class MasterDataDto implements IMasterDataDto {
    id?: string;
    masterDataTypeId?: string;
    masterDataType?: MasterDataTypeDto | undefined;
    isActive?: boolean;
    fileFields?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    propertyCount?: number;
    data?: any | undefined;

    constructor(data?: IMasterDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.masterDataTypeId = _data["masterDataTypeId"];
            this.masterDataType = _data["masterDataType"] ? MasterDataTypeDto.fromJS(_data["masterDataType"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.fileFields = _data["fileFields"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.propertyCount = _data["propertyCount"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): MasterDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["masterDataTypeId"] = this.masterDataTypeId;
        data["masterDataType"] = this.masterDataType ? this.masterDataType.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["fileFields"] = this.fileFields;
        data["value"] = this.value;
        data["name"] = this.name;
        data["propertyCount"] = this.propertyCount;
        data["data"] = this.data;
        return data;
    }
}

export interface IMasterDataDto {
    id?: string;
    masterDataTypeId?: string;
    masterDataType?: MasterDataTypeDto | undefined;
    isActive?: boolean;
    fileFields?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    propertyCount?: number;
    data?: any | undefined;
}

export class MasterDataTypeDto implements IMasterDataTypeDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: IMasterDataTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MasterDataTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterDataTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IMasterDataTypeDto {
    id?: string;
    name?: string | undefined;
}

export enum PropertyStatus {
    All = 0,
    Available = 1,
    NotAvailable = 2,
    Leasing = 3,
    Deactive = 4,
    ChangedOwner = 5,
    Expired = 6,
}

export class PropertyAmenitiesDto implements IPropertyAmenitiesDto {
    id?: string;
    propertyId?: string;
    property?: PropertyDto | undefined;
    amenitiesId?: string;
    amenities?: MasterDataDto | undefined;

    constructor(data?: IPropertyAmenitiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.property = _data["property"] ? PropertyDto.fromJS(_data["property"]) : <any>undefined;
            this.amenitiesId = _data["amenitiesId"];
            this.amenities = _data["amenities"] ? MasterDataDto.fromJS(_data["amenities"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyAmenitiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAmenitiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["property"] = this.property ? this.property.toJSON() : <any>undefined;
        data["amenitiesId"] = this.amenitiesId;
        data["amenities"] = this.amenities ? this.amenities.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyAmenitiesDto {
    id?: string;
    propertyId?: string;
    property?: PropertyDto | undefined;
    amenitiesId?: string;
    amenities?: MasterDataDto | undefined;
}

export class PropertyDto implements IPropertyDto {
    id?: string;
    propertyId?: number;
    code?: string | undefined;
    title?: string | undefined;
    location?: string | undefined;
    transactionType?: PropertyTransactionType;
    propertyTypeId?: string | undefined;
    propertyType?: MasterDataDto | undefined;
    featuresCityId?: string | undefined;
    featuresCity?: MasterDataDto | undefined;
    isActive?: boolean;
    isFeatures?: boolean;
    status?: PropertyStatus;
    displayStatus?: string | undefined;
    price?: number;
    hostInformation?: string | undefined;
    lotSize?: number;
    bathrooms?: number;
    bedrooms?: number;
    livingrooms?: number;
    balconies?: number;
    carParking?: number;
    totalFloors?: number;
    gagares?: number;
    kitchens?: number;
    pools?: number;
    insurance?: boolean;
    constructionYear?: Date | undefined;
    tags?: string | undefined;
    videoLink?: string | undefined;
    videoLinkProcess?: string | undefined;
    mapLink?: string | undefined;
    mapLinkProcess?: string | undefined;
    shortDescriptions?: string | undefined;
    descriptions?: string | undefined;
    friendlyUrl?: string | undefined;
    landlordId?: string | undefined;
    tenantId?: string | undefined;
    landlordName?: string | undefined;
    tenantName?: string | undefined;
    leaseDate?: Date | undefined;
    expiredLeasedDate?: Date | undefined;
    listPropertyAmenities?: PropertyAmenitiesDto[] | undefined;
    listPropertyImage?: PropertyImageDto[] | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.location = _data["location"];
            this.transactionType = _data["transactionType"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyType = _data["propertyType"] ? MasterDataDto.fromJS(_data["propertyType"]) : <any>undefined;
            this.featuresCityId = _data["featuresCityId"];
            this.featuresCity = _data["featuresCity"] ? MasterDataDto.fromJS(_data["featuresCity"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isFeatures = _data["isFeatures"];
            this.status = _data["status"];
            this.displayStatus = _data["displayStatus"];
            this.price = _data["price"];
            this.hostInformation = _data["hostInformation"];
            this.lotSize = _data["lotSize"];
            this.bathrooms = _data["bathrooms"];
            this.bedrooms = _data["bedrooms"];
            this.livingrooms = _data["livingrooms"];
            this.balconies = _data["balconies"];
            this.carParking = _data["carParking"];
            this.totalFloors = _data["totalFloors"];
            this.gagares = _data["gagares"];
            this.kitchens = _data["kitchens"];
            this.pools = _data["pools"];
            this.insurance = _data["insurance"];
            this.constructionYear = _data["constructionYear"] ? new Date(_data["constructionYear"].toString()) : <any>undefined;
            this.tags = _data["tags"];
            this.videoLink = _data["videoLink"];
            this.videoLinkProcess = _data["videoLinkProcess"];
            this.mapLink = _data["mapLink"];
            this.mapLinkProcess = _data["mapLinkProcess"];
            this.shortDescriptions = _data["shortDescriptions"];
            this.descriptions = _data["descriptions"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.landlordId = _data["landlordId"];
            this.tenantId = _data["tenantId"];
            this.landlordName = _data["landlordName"];
            this.tenantName = _data["tenantName"];
            this.leaseDate = _data["leaseDate"] ? new Date(_data["leaseDate"].toString()) : <any>undefined;
            this.expiredLeasedDate = _data["expiredLeasedDate"] ? new Date(_data["expiredLeasedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["listPropertyAmenities"])) {
                this.listPropertyAmenities = [] as any;
                for (let item of _data["listPropertyAmenities"])
                    this.listPropertyAmenities!.push(PropertyAmenitiesDto.fromJS(item));
            }
            if (Array.isArray(_data["listPropertyImage"])) {
                this.listPropertyImage = [] as any;
                for (let item of _data["listPropertyImage"])
                    this.listPropertyImage!.push(PropertyImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["code"] = this.code;
        data["title"] = this.title;
        data["location"] = this.location;
        data["transactionType"] = this.transactionType;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["featuresCityId"] = this.featuresCityId;
        data["featuresCity"] = this.featuresCity ? this.featuresCity.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isFeatures"] = this.isFeatures;
        data["status"] = this.status;
        data["displayStatus"] = this.displayStatus;
        data["price"] = this.price;
        data["hostInformation"] = this.hostInformation;
        data["lotSize"] = this.lotSize;
        data["bathrooms"] = this.bathrooms;
        data["bedrooms"] = this.bedrooms;
        data["livingrooms"] = this.livingrooms;
        data["balconies"] = this.balconies;
        data["carParking"] = this.carParking;
        data["totalFloors"] = this.totalFloors;
        data["gagares"] = this.gagares;
        data["kitchens"] = this.kitchens;
        data["pools"] = this.pools;
        data["insurance"] = this.insurance;
        data["constructionYear"] = this.constructionYear ? this.constructionYear.toISOString() : <any>undefined;
        data["tags"] = this.tags;
        data["videoLink"] = this.videoLink;
        data["videoLinkProcess"] = this.videoLinkProcess;
        data["mapLink"] = this.mapLink;
        data["mapLinkProcess"] = this.mapLinkProcess;
        data["shortDescriptions"] = this.shortDescriptions;
        data["descriptions"] = this.descriptions;
        data["friendlyUrl"] = this.friendlyUrl;
        data["landlordId"] = this.landlordId;
        data["tenantId"] = this.tenantId;
        data["landlordName"] = this.landlordName;
        data["tenantName"] = this.tenantName;
        data["leaseDate"] = this.leaseDate ? this.leaseDate.toISOString() : <any>undefined;
        data["expiredLeasedDate"] = this.expiredLeasedDate ? this.expiredLeasedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.listPropertyAmenities)) {
            data["listPropertyAmenities"] = [];
            for (let item of this.listPropertyAmenities)
                data["listPropertyAmenities"].push(item.toJSON());
        }
        if (Array.isArray(this.listPropertyImage)) {
            data["listPropertyImage"] = [];
            for (let item of this.listPropertyImage)
                data["listPropertyImage"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPropertyDto {
    id?: string;
    propertyId?: number;
    code?: string | undefined;
    title?: string | undefined;
    location?: string | undefined;
    transactionType?: PropertyTransactionType;
    propertyTypeId?: string | undefined;
    propertyType?: MasterDataDto | undefined;
    featuresCityId?: string | undefined;
    featuresCity?: MasterDataDto | undefined;
    isActive?: boolean;
    isFeatures?: boolean;
    status?: PropertyStatus;
    displayStatus?: string | undefined;
    price?: number;
    hostInformation?: string | undefined;
    lotSize?: number;
    bathrooms?: number;
    bedrooms?: number;
    livingrooms?: number;
    balconies?: number;
    carParking?: number;
    totalFloors?: number;
    gagares?: number;
    kitchens?: number;
    pools?: number;
    insurance?: boolean;
    constructionYear?: Date | undefined;
    tags?: string | undefined;
    videoLink?: string | undefined;
    videoLinkProcess?: string | undefined;
    mapLink?: string | undefined;
    mapLinkProcess?: string | undefined;
    shortDescriptions?: string | undefined;
    descriptions?: string | undefined;
    friendlyUrl?: string | undefined;
    landlordId?: string | undefined;
    tenantId?: string | undefined;
    landlordName?: string | undefined;
    tenantName?: string | undefined;
    leaseDate?: Date | undefined;
    expiredLeasedDate?: Date | undefined;
    listPropertyAmenities?: PropertyAmenitiesDto[] | undefined;
    listPropertyImage?: PropertyImageDto[] | undefined;
}

export class PropertyImageDto implements IPropertyImageDto {
    id?: string;
    propertyId?: string;
    property?: PropertyDto | undefined;
    propertyImageType?: PropertyImageType;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;

    constructor(data?: IPropertyImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.property = _data["property"] ? PropertyDto.fromJS(_data["property"]) : <any>undefined;
            this.propertyImageType = _data["propertyImageType"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.imageName = _data["imageName"];
        }
    }

    static fromJS(data: any): PropertyImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["property"] = this.property ? this.property.toJSON() : <any>undefined;
        data["propertyImageType"] = this.propertyImageType;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["imageName"] = this.imageName;
        return data;
    }
}

export interface IPropertyImageDto {
    id?: string;
    propertyId?: string;
    property?: PropertyDto | undefined;
    propertyImageType?: PropertyImageType;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;
}

export enum PropertyImageType {
    ThumbnailImage = 1,
    CoverImage = 2,
    OthersImage = 3,
}

export class CreateMaintenanceRequestDto implements ICreateMaintenanceRequestDto {
    propertyId?: string;
    listMaintenanceAreaId?: string[] | undefined;
    listErrorTypeId?: string[] | undefined;
    listErrorDetailsId?: string[] | undefined;
    maintenanceRequestImages?: MaintenanceRequestImageDto[] | undefined;
    notes?: string | undefined;

    constructor(data?: ICreateMaintenanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            if (Array.isArray(_data["listMaintenanceAreaId"])) {
                this.listMaintenanceAreaId = [] as any;
                for (let item of _data["listMaintenanceAreaId"])
                    this.listMaintenanceAreaId!.push(item);
            }
            if (Array.isArray(_data["listErrorTypeId"])) {
                this.listErrorTypeId = [] as any;
                for (let item of _data["listErrorTypeId"])
                    this.listErrorTypeId!.push(item);
            }
            if (Array.isArray(_data["listErrorDetailsId"])) {
                this.listErrorDetailsId = [] as any;
                for (let item of _data["listErrorDetailsId"])
                    this.listErrorDetailsId!.push(item);
            }
            if (Array.isArray(_data["maintenanceRequestImages"])) {
                this.maintenanceRequestImages = [] as any;
                for (let item of _data["maintenanceRequestImages"])
                    this.maintenanceRequestImages!.push(MaintenanceRequestImageDto.fromJS(item));
            }
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateMaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        if (Array.isArray(this.listMaintenanceAreaId)) {
            data["listMaintenanceAreaId"] = [];
            for (let item of this.listMaintenanceAreaId)
                data["listMaintenanceAreaId"].push(item);
        }
        if (Array.isArray(this.listErrorTypeId)) {
            data["listErrorTypeId"] = [];
            for (let item of this.listErrorTypeId)
                data["listErrorTypeId"].push(item);
        }
        if (Array.isArray(this.listErrorDetailsId)) {
            data["listErrorDetailsId"] = [];
            for (let item of this.listErrorDetailsId)
                data["listErrorDetailsId"].push(item);
        }
        if (Array.isArray(this.maintenanceRequestImages)) {
            data["maintenanceRequestImages"] = [];
            for (let item of this.maintenanceRequestImages)
                data["maintenanceRequestImages"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateMaintenanceRequestDto {
    propertyId?: string;
    listMaintenanceAreaId?: string[] | undefined;
    listErrorTypeId?: string[] | undefined;
    listErrorDetailsId?: string[] | undefined;
    maintenanceRequestImages?: MaintenanceRequestImageDto[] | undefined;
    notes?: string | undefined;
}

export class MaintenanceRequestImageDto implements IMaintenanceRequestImageDto {
    id?: string | undefined;
    maintenanceRequestId?: string | undefined;
    maintenanceRequest?: MaintenanceRequestDto | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;

    constructor(data?: IMaintenanceRequestImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            this.maintenanceRequest = _data["maintenanceRequest"] ? MaintenanceRequestDto.fromJS(_data["maintenanceRequest"]) : <any>undefined;
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.imageName = _data["imageName"];
        }
    }

    static fromJS(data: any): MaintenanceRequestImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        data["maintenanceRequest"] = this.maintenanceRequest ? this.maintenanceRequest.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["imageName"] = this.imageName;
        return data;
    }
}

export interface IMaintenanceRequestImageDto {
    id?: string | undefined;
    maintenanceRequestId?: string | undefined;
    maintenanceRequest?: MaintenanceRequestDto | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;
}

export abstract class AuditableDto implements IAuditableDto {
    createdBy?: string | undefined;
    created?: Date;

    constructor(data?: IAuditableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditableDto {
    createdBy?: string | undefined;
    created?: Date;
}

export class MaintenanceRequestDto extends AuditableDto implements IMaintenanceRequestDto {
    id?: string;
    ticketId?: number;
    propertyId?: string;
    property?: PropertyDto | undefined;
    finishedDate?: Date | undefined;
    ticketStatus?: MaintenanceRequestStatus;
    paymentStatus?: PaymentStatus;
    notes?: string | undefined;
    maintenanceRequestImages?: MaintenanceRequestImageDto[] | undefined;
    maintenanceRequestDetails?: MaintenanceRequestDetailDto[] | undefined;
    listMaintenanceArea?: MaintenanceRequestDetailDto[] | undefined;
    listErrorType?: MaintenanceRequestDetailDto[] | undefined;
    listErrorDetails?: MaintenanceRequestDetailDto[] | undefined;

    constructor(data?: IMaintenanceRequestDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.ticketId = _data["ticketId"];
            this.propertyId = _data["propertyId"];
            this.property = _data["property"] ? PropertyDto.fromJS(_data["property"]) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? new Date(_data["finishedDate"].toString()) : <any>undefined;
            this.ticketStatus = _data["ticketStatus"];
            this.paymentStatus = _data["paymentStatus"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["maintenanceRequestImages"])) {
                this.maintenanceRequestImages = [] as any;
                for (let item of _data["maintenanceRequestImages"])
                    this.maintenanceRequestImages!.push(MaintenanceRequestImageDto.fromJS(item));
            }
            if (Array.isArray(_data["maintenanceRequestDetails"])) {
                this.maintenanceRequestDetails = [] as any;
                for (let item of _data["maintenanceRequestDetails"])
                    this.maintenanceRequestDetails!.push(MaintenanceRequestDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["listMaintenanceArea"])) {
                this.listMaintenanceArea = [] as any;
                for (let item of _data["listMaintenanceArea"])
                    this.listMaintenanceArea!.push(MaintenanceRequestDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["listErrorType"])) {
                this.listErrorType = [] as any;
                for (let item of _data["listErrorType"])
                    this.listErrorType!.push(MaintenanceRequestDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["listErrorDetails"])) {
                this.listErrorDetails = [] as any;
                for (let item of _data["listErrorDetails"])
                    this.listErrorDetails!.push(MaintenanceRequestDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["propertyId"] = this.propertyId;
        data["property"] = this.property ? this.property.toJSON() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toISOString() : <any>undefined;
        data["ticketStatus"] = this.ticketStatus;
        data["paymentStatus"] = this.paymentStatus;
        data["notes"] = this.notes;
        if (Array.isArray(this.maintenanceRequestImages)) {
            data["maintenanceRequestImages"] = [];
            for (let item of this.maintenanceRequestImages)
                data["maintenanceRequestImages"].push(item.toJSON());
        }
        if (Array.isArray(this.maintenanceRequestDetails)) {
            data["maintenanceRequestDetails"] = [];
            for (let item of this.maintenanceRequestDetails)
                data["maintenanceRequestDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.listMaintenanceArea)) {
            data["listMaintenanceArea"] = [];
            for (let item of this.listMaintenanceArea)
                data["listMaintenanceArea"].push(item.toJSON());
        }
        if (Array.isArray(this.listErrorType)) {
            data["listErrorType"] = [];
            for (let item of this.listErrorType)
                data["listErrorType"].push(item.toJSON());
        }
        if (Array.isArray(this.listErrorDetails)) {
            data["listErrorDetails"] = [];
            for (let item of this.listErrorDetails)
                data["listErrorDetails"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMaintenanceRequestDto extends IAuditableDto {
    id?: string;
    ticketId?: number;
    propertyId?: string;
    property?: PropertyDto | undefined;
    finishedDate?: Date | undefined;
    ticketStatus?: MaintenanceRequestStatus;
    paymentStatus?: PaymentStatus;
    notes?: string | undefined;
    maintenanceRequestImages?: MaintenanceRequestImageDto[] | undefined;
    maintenanceRequestDetails?: MaintenanceRequestDetailDto[] | undefined;
    listMaintenanceArea?: MaintenanceRequestDetailDto[] | undefined;
    listErrorType?: MaintenanceRequestDetailDto[] | undefined;
    listErrorDetails?: MaintenanceRequestDetailDto[] | undefined;
}

export enum MaintenanceRequestStatus {
    All = 0,
    New = 1,
    InProgress = 2,
    Rejected = 3,
    Approved = 4,
    Done = 5,
}

export enum PaymentStatus {
    All = 0,
    New = 1,
    Unpaid = 2,
    Paid = 3,
}

export class MaintenanceRequestDetailDto implements IMaintenanceRequestDetailDto {
    id?: string;
    maintenanceRequestId?: string;
    maintenanceRequest?: MaintenanceRequestDto | undefined;
    masterDataId?: string | undefined;
    masterData?: MasterDataDto | undefined;
    detailType?: MaintenanceRequestDetailType;

    constructor(data?: IMaintenanceRequestDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            this.maintenanceRequest = _data["maintenanceRequest"] ? MaintenanceRequestDto.fromJS(_data["maintenanceRequest"]) : <any>undefined;
            this.masterDataId = _data["masterDataId"];
            this.masterData = _data["masterData"] ? MasterDataDto.fromJS(_data["masterData"]) : <any>undefined;
            this.detailType = _data["detailType"];
        }
    }

    static fromJS(data: any): MaintenanceRequestDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        data["maintenanceRequest"] = this.maintenanceRequest ? this.maintenanceRequest.toJSON() : <any>undefined;
        data["masterDataId"] = this.masterDataId;
        data["masterData"] = this.masterData ? this.masterData.toJSON() : <any>undefined;
        data["detailType"] = this.detailType;
        return data;
    }
}

export interface IMaintenanceRequestDetailDto {
    id?: string;
    maintenanceRequestId?: string;
    maintenanceRequest?: MaintenanceRequestDto | undefined;
    masterDataId?: string | undefined;
    masterData?: MasterDataDto | undefined;
    detailType?: MaintenanceRequestDetailType;
}

export enum MaintenanceRequestDetailType {
    MaintenanceArea = 1,
    ErrorType = 2,
    ErrorDetails = 3,
}

export class PaginatedListOfMaintenanceRequestDto implements IPaginatedListOfMaintenanceRequestDto {
    items?: MaintenanceRequestDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMaintenanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaintenanceRequestDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfMaintenanceRequestDto {
    items?: MaintenanceRequestDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MaintenanceRequestFilterDto implements IMaintenanceRequestFilterDto {
    pageNumber?: number;
    pageSize?: number;
    searchText?: string | undefined;
    listPaymentStatus?: PaymentStatus[] | undefined;
    listTicketStatus?: MaintenanceRequestStatus[] | undefined;

    constructor(data?: IMaintenanceRequestFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.searchText = _data["searchText"];
            if (Array.isArray(_data["listPaymentStatus"])) {
                this.listPaymentStatus = [] as any;
                for (let item of _data["listPaymentStatus"])
                    this.listPaymentStatus!.push(item);
            }
            if (Array.isArray(_data["listTicketStatus"])) {
                this.listTicketStatus = [] as any;
                for (let item of _data["listTicketStatus"])
                    this.listTicketStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): MaintenanceRequestFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["searchText"] = this.searchText;
        if (Array.isArray(this.listPaymentStatus)) {
            data["listPaymentStatus"] = [];
            for (let item of this.listPaymentStatus)
                data["listPaymentStatus"].push(item);
        }
        if (Array.isArray(this.listTicketStatus)) {
            data["listTicketStatus"] = [];
            for (let item of this.listTicketStatus)
                data["listTicketStatus"].push(item);
        }
        return data;
    }
}

export interface IMaintenanceRequestFilterDto {
    pageNumber?: number;
    pageSize?: number;
    searchText?: string | undefined;
    listPaymentStatus?: PaymentStatus[] | undefined;
    listTicketStatus?: MaintenanceRequestStatus[] | undefined;
}

export class MaintenanceRequestStatusDto implements IMaintenanceRequestStatusDto {
    status?: MaintenanceRequestStatus;
    statusText?: string | undefined;
    numberOfTicket?: number;

    constructor(data?: IMaintenanceRequestStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.statusText = _data["statusText"];
            this.numberOfTicket = _data["numberOfTicket"];
        }
    }

    static fromJS(data: any): MaintenanceRequestStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["statusText"] = this.statusText;
        data["numberOfTicket"] = this.numberOfTicket;
        return data;
    }
}

export interface IMaintenanceRequestStatusDto {
    status?: MaintenanceRequestStatus;
    statusText?: string | undefined;
    numberOfTicket?: number;
}

export class ApproveMaintenanceRequestDto implements IApproveMaintenanceRequestDto {
    maintenanceRequestId?: string;
    isApprove?: boolean;
    isReject?: boolean;
    notes?: string | undefined;

    constructor(data?: IApproveMaintenanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            this.isApprove = _data["isApprove"];
            this.isReject = _data["isReject"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ApproveMaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveMaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        data["isApprove"] = this.isApprove;
        data["isReject"] = this.isReject;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IApproveMaintenanceRequestDto {
    maintenanceRequestId?: string;
    isApprove?: boolean;
    isReject?: boolean;
    notes?: string | undefined;
}

export class ProceedMaintenanceRequestDto implements IProceedMaintenanceRequestDto {
    maintenanceRequestId?: string;
    notes?: string | undefined;

    constructor(data?: IProceedMaintenanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ProceedMaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProceedMaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IProceedMaintenanceRequestDto {
    maintenanceRequestId?: string;
    notes?: string | undefined;
}

export class DoneMaintenanceRequestDto implements IDoneMaintenanceRequestDto {
    maintenanceRequestId?: string;
    maintenanceRequestOperationImages?: MaintenanceRequestOperationImageDto[] | undefined;
    notes?: string | undefined;

    constructor(data?: IDoneMaintenanceRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            if (Array.isArray(_data["maintenanceRequestOperationImages"])) {
                this.maintenanceRequestOperationImages = [] as any;
                for (let item of _data["maintenanceRequestOperationImages"])
                    this.maintenanceRequestOperationImages!.push(MaintenanceRequestOperationImageDto.fromJS(item));
            }
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): DoneMaintenanceRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoneMaintenanceRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        if (Array.isArray(this.maintenanceRequestOperationImages)) {
            data["maintenanceRequestOperationImages"] = [];
            for (let item of this.maintenanceRequestOperationImages)
                data["maintenanceRequestOperationImages"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        return data;
    }
}

export interface IDoneMaintenanceRequestDto {
    maintenanceRequestId?: string;
    maintenanceRequestOperationImages?: MaintenanceRequestOperationImageDto[] | undefined;
    notes?: string | undefined;
}

export class MaintenanceRequestOperationImageDto implements IMaintenanceRequestOperationImageDto {
    id?: string | undefined;
    maintenanceRequestOperationId?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;

    constructor(data?: IMaintenanceRequestOperationImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maintenanceRequestOperationId = _data["maintenanceRequestOperationId"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.imageName = _data["imageName"];
        }
    }

    static fromJS(data: any): MaintenanceRequestOperationImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestOperationImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maintenanceRequestOperationId"] = this.maintenanceRequestOperationId;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["imageName"] = this.imageName;
        return data;
    }
}

export interface IMaintenanceRequestOperationImageDto {
    id?: string | undefined;
    maintenanceRequestOperationId?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;
}

export class MaintenanceRequestOperationInfoDto implements IMaintenanceRequestOperationInfoDto {
    id?: string;
    maintenanceRequestId?: string;
    content?: string | undefined;
    approver?: string | undefined;
    reason?: string | undefined;
    created?: Date | undefined;

    constructor(data?: IMaintenanceRequestOperationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maintenanceRequestId = _data["maintenanceRequestId"];
            this.content = _data["content"];
            this.approver = _data["approver"];
            this.reason = _data["reason"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MaintenanceRequestOperationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceRequestOperationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maintenanceRequestId"] = this.maintenanceRequestId;
        data["content"] = this.content;
        data["approver"] = this.approver;
        data["reason"] = this.reason;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMaintenanceRequestOperationInfoDto {
    id?: string;
    maintenanceRequestId?: string;
    content?: string | undefined;
    approver?: string | undefined;
    reason?: string | undefined;
    created?: Date | undefined;
}

export class CreateMasterDataDto implements ICreateMasterDataDto {
    masterDataTypeId?: string;
    isActive?: boolean;
    fileFields?: string[] | undefined;
    value?: string | undefined;
    name?: string | undefined;
    data?: any | undefined;

    constructor(data?: ICreateMasterDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterDataTypeId = _data["masterDataTypeId"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["fileFields"])) {
                this.fileFields = [] as any;
                for (let item of _data["fileFields"])
                    this.fileFields!.push(item);
            }
            this.value = _data["value"];
            this.name = _data["name"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CreateMasterDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMasterDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterDataTypeId"] = this.masterDataTypeId;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.fileFields)) {
            data["fileFields"] = [];
            for (let item of this.fileFields)
                data["fileFields"].push(item);
        }
        data["value"] = this.value;
        data["name"] = this.name;
        data["data"] = this.data;
        return data;
    }
}

export interface ICreateMasterDataDto {
    masterDataTypeId?: string;
    isActive?: boolean;
    fileFields?: string[] | undefined;
    value?: string | undefined;
    name?: string | undefined;
    data?: any | undefined;
}

export class NewsCategoryDto extends AuditableEntity implements INewsCategoryDto {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;

    constructor(data?: INewsCategoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): NewsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        super.toJSON(data);
        return data;
    }
}

export interface INewsCategoryDto extends IAuditableEntity {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
}

export class CreateNewsCategoryDto implements ICreateNewsCategoryDto {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;

    constructor(data?: ICreateNewsCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): CreateNewsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        return data;
    }
}

export interface ICreateNewsCategoryDto {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
}

export class NewsDto extends AuditableEntity implements INewsDto {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean;
    featured?: boolean;
    isHomeView?: boolean;
    isHotNews?: boolean;
    friendlyUrl?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    location?: string | undefined;
    category?: NewsCategoryDto | undefined;
    listImages?: NewsImageDto[] | undefined;
    fromToDateFormat?: string | undefined;

    constructor(data?: INewsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.keyword = _data["keyword"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.views = _data["views"];
            this.categoryId = _data["categoryId"];
            this.isActived = _data["isActived"];
            this.featured = _data["featured"];
            this.isHomeView = _data["isHomeView"];
            this.isHotNews = _data["isHotNews"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.location = _data["location"];
            this.category = _data["category"] ? NewsCategoryDto.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["listImages"])) {
                this.listImages = [] as any;
                for (let item of _data["listImages"])
                    this.listImages!.push(NewsImageDto.fromJS(item));
            }
            this.fromToDateFormat = _data["fromToDateFormat"];
        }
    }

    static fromJS(data: any): NewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["keyword"] = this.keyword;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["views"] = this.views;
        data["categoryId"] = this.categoryId;
        data["isActived"] = this.isActived;
        data["featured"] = this.featured;
        data["isHomeView"] = this.isHomeView;
        data["isHotNews"] = this.isHotNews;
        data["friendlyUrl"] = this.friendlyUrl;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.listImages)) {
            data["listImages"] = [];
            for (let item of this.listImages)
                data["listImages"].push(item.toJSON());
        }
        data["fromToDateFormat"] = this.fromToDateFormat;
        super.toJSON(data);
        return data;
    }
}

export interface INewsDto extends IAuditableEntity {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean;
    featured?: boolean;
    isHomeView?: boolean;
    isHotNews?: boolean;
    friendlyUrl?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    location?: string | undefined;
    category?: NewsCategoryDto | undefined;
    listImages?: NewsImageDto[] | undefined;
    fromToDateFormat?: string | undefined;
}

export class NewsImageDto implements INewsImageDto {
    id?: string;
    imageName?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    newsId?: string;

    constructor(data?: INewsImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imageName = _data["imageName"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.newsId = _data["newsId"];
        }
    }

    static fromJS(data: any): NewsImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageName"] = this.imageName;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["newsId"] = this.newsId;
        return data;
    }
}

export interface INewsImageDto {
    id?: string;
    imageName?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    newsId?: string;
}

export class PaginatedListOfNewsDto implements IPaginatedListOfNewsDto {
    items?: NewsDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NewsDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfNewsDto {
    items?: NewsDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FilterNewsDto implements IFilterNewsDto {
    pageNumber?: number;
    pageSize?: number;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    isActived?: boolean | undefined;
    isHotNews?: boolean | undefined;
    categoryId?: string | undefined;
    sortNewest?: boolean;
    sortOldest?: boolean;

    constructor(data?: IFilterNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.keyword = _data["keyword"];
            this.isActived = _data["isActived"];
            this.isHotNews = _data["isHotNews"];
            this.categoryId = _data["categoryId"];
            this.sortNewest = _data["sortNewest"];
            this.sortOldest = _data["sortOldest"];
        }
    }

    static fromJS(data: any): FilterNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["keyword"] = this.keyword;
        data["isActived"] = this.isActived;
        data["isHotNews"] = this.isHotNews;
        data["categoryId"] = this.categoryId;
        data["sortNewest"] = this.sortNewest;
        data["sortOldest"] = this.sortOldest;
        return data;
    }
}

export interface IFilterNewsDto {
    pageNumber?: number;
    pageSize?: number;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    isActived?: boolean | undefined;
    isHotNews?: boolean | undefined;
    categoryId?: string | undefined;
    sortNewest?: boolean;
    sortOldest?: boolean;
}

export class CreateNewsDto implements ICreateNewsDto {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean | undefined;
    featured?: boolean | undefined;
    isHomeView?: boolean | undefined;
    isHotNews?: boolean;
    friendlyUrl?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    location?: string | undefined;
    listImages?: NewsImageDto[] | undefined;

    constructor(data?: ICreateNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.keyword = _data["keyword"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.imageUrl = _data["imageUrl"];
            this.imageName = _data["imageName"];
            this.views = _data["views"];
            this.categoryId = _data["categoryId"];
            this.isActived = _data["isActived"];
            this.featured = _data["featured"];
            this.isHomeView = _data["isHomeView"];
            this.isHotNews = _data["isHotNews"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.location = _data["location"];
            if (Array.isArray(_data["listImages"])) {
                this.listImages = [] as any;
                for (let item of _data["listImages"])
                    this.listImages!.push(NewsImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["keyword"] = this.keyword;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["imageUrl"] = this.imageUrl;
        data["imageName"] = this.imageName;
        data["views"] = this.views;
        data["categoryId"] = this.categoryId;
        data["isActived"] = this.isActived;
        data["featured"] = this.featured;
        data["isHomeView"] = this.isHomeView;
        data["isHotNews"] = this.isHotNews;
        data["friendlyUrl"] = this.friendlyUrl;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        if (Array.isArray(this.listImages)) {
            data["listImages"] = [];
            for (let item of this.listImages)
                data["listImages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateNewsDto {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean | undefined;
    featured?: boolean | undefined;
    isHomeView?: boolean | undefined;
    isHotNews?: boolean;
    friendlyUrl?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    location?: string | undefined;
    listImages?: NewsImageDto[] | undefined;
}

export class SearchingNewsDto implements ISearchingNewsDto {
    title?: string | undefined;
    featured?: boolean | undefined;

    constructor(data?: ISearchingNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.featured = _data["featured"];
        }
    }

    static fromJS(data: any): SearchingNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["featured"] = this.featured;
        return data;
    }
}

export interface ISearchingNewsDto {
    title?: string | undefined;
    featured?: boolean | undefined;
}

export class PhotoDto implements IPhotoDto {
    id?: string;
    caption?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    thumbNail?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;

    constructor(data?: IPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caption = _data["caption"];
            this.imageUrl = _data["imageUrl"];
            this.imageName = _data["imageName"];
            this.thumbNail = _data["thumbNail"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caption"] = this.caption;
        data["imageUrl"] = this.imageUrl;
        data["imageName"] = this.imageName;
        data["thumbNail"] = this.thumbNail;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPhotoDto {
    id?: string;
    caption?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    thumbNail?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
}

export class PaginatedListOfPropertyDto implements IPaginatedListOfPropertyDto {
    items?: PropertyDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPropertyDto {
    items?: PropertyDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FilterMyPropertyDto implements IFilterMyPropertyDto {
    pageNumber?: number;
    pageSize?: number;
    searchText?: string | undefined;
    listStatus?: PropertyStatus[] | undefined;

    constructor(data?: IFilterMyPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.searchText = _data["searchText"];
            if (Array.isArray(_data["listStatus"])) {
                this.listStatus = [] as any;
                for (let item of _data["listStatus"])
                    this.listStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): FilterMyPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterMyPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["searchText"] = this.searchText;
        if (Array.isArray(this.listStatus)) {
            data["listStatus"] = [];
            for (let item of this.listStatus)
                data["listStatus"].push(item);
        }
        return data;
    }
}

export interface IFilterMyPropertyDto {
    pageNumber?: number;
    pageSize?: number;
    searchText?: string | undefined;
    listStatus?: PropertyStatus[] | undefined;
}

export class PropertyHistoryDto implements IPropertyHistoryDto {
    id?: string;
    propertyId?: string;
    fromTime?: Date;
    toTime?: Date | undefined;
    userId?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    changeUserId?: string | undefined;
    changeFullName?: string | undefined;
    changeEmail?: string | undefined;
    actionType?: PropertyActionType;
    descriptions?: string | undefined;
    created?: Date;

    constructor(data?: IPropertyHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.fromTime = _data["fromTime"] ? new Date(_data["fromTime"].toString()) : <any>undefined;
            this.toTime = _data["toTime"] ? new Date(_data["toTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.changeUserId = _data["changeUserId"];
            this.changeFullName = _data["changeFullName"];
            this.changeEmail = _data["changeEmail"];
            this.actionType = _data["actionType"];
            this.descriptions = _data["descriptions"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["fromTime"] = this.fromTime ? this.fromTime.toISOString() : <any>undefined;
        data["toTime"] = this.toTime ? this.toTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["changeUserId"] = this.changeUserId;
        data["changeFullName"] = this.changeFullName;
        data["changeEmail"] = this.changeEmail;
        data["actionType"] = this.actionType;
        data["descriptions"] = this.descriptions;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPropertyHistoryDto {
    id?: string;
    propertyId?: string;
    fromTime?: Date;
    toTime?: Date | undefined;
    userId?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    changeUserId?: string | undefined;
    changeFullName?: string | undefined;
    changeEmail?: string | undefined;
    actionType?: PropertyActionType;
    descriptions?: string | undefined;
    created?: Date;
}

export enum PropertyActionType {
    RegisterLandlord = 1,
    RegisterTenant = 2,
    RemoveTenant = 3,
    ExpiredTenant = 4,
    ChangeLandlord = 5,
    DeactiveProperty = 6,
}

export class PropertyStatusDto implements IPropertyStatusDto {
    status?: PropertyStatus;
    displayStatus?: string | undefined;
    propertyCount?: number;

    constructor(data?: IPropertyStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.displayStatus = _data["displayStatus"];
            this.propertyCount = _data["propertyCount"];
        }
    }

    static fromJS(data: any): PropertyStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["displayStatus"] = this.displayStatus;
        data["propertyCount"] = this.propertyCount;
        return data;
    }
}

export interface IPropertyStatusDto {
    status?: PropertyStatus;
    displayStatus?: string | undefined;
    propertyCount?: number;
}

export class ProjectDto implements IProjectDto {
    id?: string;
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    shortDescriptionsVi?: string | undefined;
    shortDescriptionsEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    hightlightProject?: boolean;
    price?: string | undefined;
    dimensions?: string | undefined;
    address?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    startDate?: Date | undefined;
    finishedDate?: Date | undefined;
    projectTypeName?: string | undefined;
    created?: Date;
    projectTypeId?: string;
    projectType?: ProjectTypeDto | undefined;
    projectImages?: ProjectImageDto[] | undefined;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectCode = _data["projectCode"];
            this.projectNameVi = _data["projectNameVi"];
            this.projectNameEn = _data["projectNameEn"];
            this.shortDescriptionsVi = _data["shortDescriptionsVi"];
            this.shortDescriptionsEn = _data["shortDescriptionsEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.hightlightProject = _data["hightlightProject"];
            this.price = _data["price"];
            this.dimensions = _data["dimensions"];
            this.address = _data["address"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? new Date(_data["finishedDate"].toString()) : <any>undefined;
            this.projectTypeName = _data["projectTypeName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.projectTypeId = _data["projectTypeId"];
            this.projectType = _data["projectType"] ? ProjectTypeDto.fromJS(_data["projectType"]) : <any>undefined;
            if (Array.isArray(_data["projectImages"])) {
                this.projectImages = [] as any;
                for (let item of _data["projectImages"])
                    this.projectImages!.push(ProjectImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectCode"] = this.projectCode;
        data["projectNameVi"] = this.projectNameVi;
        data["projectNameEn"] = this.projectNameEn;
        data["shortDescriptionsVi"] = this.shortDescriptionsVi;
        data["shortDescriptionsEn"] = this.shortDescriptionsEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["hightlightProject"] = this.hightlightProject;
        data["price"] = this.price;
        data["dimensions"] = this.dimensions;
        data["address"] = this.address;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toISOString() : <any>undefined;
        data["projectTypeName"] = this.projectTypeName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["projectTypeId"] = this.projectTypeId;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        if (Array.isArray(this.projectImages)) {
            data["projectImages"] = [];
            for (let item of this.projectImages)
                data["projectImages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProjectDto {
    id?: string;
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    shortDescriptionsVi?: string | undefined;
    shortDescriptionsEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    hightlightProject?: boolean;
    price?: string | undefined;
    dimensions?: string | undefined;
    address?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    startDate?: Date | undefined;
    finishedDate?: Date | undefined;
    projectTypeName?: string | undefined;
    created?: Date;
    projectTypeId?: string;
    projectType?: ProjectTypeDto | undefined;
    projectImages?: ProjectImageDto[] | undefined;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id?: string;
    code?: string | undefined;
    nameVi?: string | undefined;
    nameEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    created?: Date;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.nameVi = _data["nameVi"];
            this.nameEn = _data["nameEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["nameVi"] = this.nameVi;
        data["nameEn"] = this.nameEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProjectTypeDto {
    id?: string;
    code?: string | undefined;
    nameVi?: string | undefined;
    nameEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    created?: Date;
}

export class ProjectImageDto implements IProjectImageDto {
    id?: string;
    projectId?: string;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;

    constructor(data?: IProjectImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.imageName = _data["imageName"];
        }
    }

    static fromJS(data: any): ProjectImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["imageName"] = this.imageName;
        return data;
    }
}

export interface IProjectImageDto {
    id?: string;
    projectId?: string;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    imageName?: string | undefined;
}

export class CreateProjectDto implements ICreateProjectDto {
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    shortDescriptionsVi?: string | undefined;
    shortDescriptionsEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    hightlightProject?: boolean;
    price?: string | undefined;
    dimensions?: string | undefined;
    address?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    startDate?: Date | undefined;
    finishedDate?: Date | undefined;
    projectTypeId?: string;
    projectImages?: ProjectImageDto[] | undefined;

    constructor(data?: ICreateProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectCode = _data["projectCode"];
            this.projectNameVi = _data["projectNameVi"];
            this.projectNameEn = _data["projectNameEn"];
            this.shortDescriptionsVi = _data["shortDescriptionsVi"];
            this.shortDescriptionsEn = _data["shortDescriptionsEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.hightlightProject = _data["hightlightProject"];
            this.price = _data["price"];
            this.dimensions = _data["dimensions"];
            this.address = _data["address"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.finishedDate = _data["finishedDate"] ? new Date(_data["finishedDate"].toString()) : <any>undefined;
            this.projectTypeId = _data["projectTypeId"];
            if (Array.isArray(_data["projectImages"])) {
                this.projectImages = [] as any;
                for (let item of _data["projectImages"])
                    this.projectImages!.push(ProjectImageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCode"] = this.projectCode;
        data["projectNameVi"] = this.projectNameVi;
        data["projectNameEn"] = this.projectNameEn;
        data["shortDescriptionsVi"] = this.shortDescriptionsVi;
        data["shortDescriptionsEn"] = this.shortDescriptionsEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["hightlightProject"] = this.hightlightProject;
        data["price"] = this.price;
        data["dimensions"] = this.dimensions;
        data["address"] = this.address;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["finishedDate"] = this.finishedDate ? this.finishedDate.toISOString() : <any>undefined;
        data["projectTypeId"] = this.projectTypeId;
        if (Array.isArray(this.projectImages)) {
            data["projectImages"] = [];
            for (let item of this.projectImages)
                data["projectImages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateProjectDto {
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    shortDescriptionsVi?: string | undefined;
    shortDescriptionsEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    hightlightProject?: boolean;
    price?: string | undefined;
    dimensions?: string | undefined;
    address?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
    startDate?: Date | undefined;
    finishedDate?: Date | undefined;
    projectTypeId?: string;
    projectImages?: ProjectImageDto[] | undefined;
}

export class PaginatedListOfProjectDto implements IPaginatedListOfProjectDto {
    items?: ProjectDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProjectDto {
    items?: ProjectDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProjectFilterDto implements IProjectFilterDto {
    pageNumber?: number;
    pageSize?: number;
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    hightlightProject?: boolean | undefined;
    isActived?: boolean | undefined;
    projectTypeId?: string | undefined;

    constructor(data?: IProjectFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.projectCode = _data["projectCode"];
            this.projectNameVi = _data["projectNameVi"];
            this.projectNameEn = _data["projectNameEn"];
            this.hightlightProject = _data["hightlightProject"];
            this.isActived = _data["isActived"];
            this.projectTypeId = _data["projectTypeId"];
        }
    }

    static fromJS(data: any): ProjectFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["projectCode"] = this.projectCode;
        data["projectNameVi"] = this.projectNameVi;
        data["projectNameEn"] = this.projectNameEn;
        data["hightlightProject"] = this.hightlightProject;
        data["isActived"] = this.isActived;
        data["projectTypeId"] = this.projectTypeId;
        return data;
    }
}

export interface IProjectFilterDto {
    pageNumber?: number;
    pageSize?: number;
    projectCode?: string | undefined;
    projectNameVi?: string | undefined;
    projectNameEn?: string | undefined;
    hightlightProject?: boolean | undefined;
    isActived?: boolean | undefined;
    projectTypeId?: string | undefined;
}

export class CreateProjectTypeDto implements ICreateProjectTypeDto {
    code?: string | undefined;
    nameVi?: string | undefined;
    nameEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;

    constructor(data?: ICreateProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.nameVi = _data["nameVi"];
            this.nameEn = _data["nameEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.isActived = _data["isActived"];
            this.friendlyUrl = _data["friendlyUrl"];
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): CreateProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["nameVi"] = this.nameVi;
        data["nameEn"] = this.nameEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["isActived"] = this.isActived;
        data["friendlyUrl"] = this.friendlyUrl;
        data["keyword"] = this.keyword;
        return data;
    }
}

export interface ICreateProjectTypeDto {
    code?: string | undefined;
    nameVi?: string | undefined;
    nameEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    isActived?: boolean;
    friendlyUrl?: string | undefined;
    keyword?: string | undefined;
}

export class CreateLandlordDto implements ICreateLandlordDto {
    propertyId?: string;
    userId?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICreateLandlordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.userId = _data["userId"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateLandlordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLandlordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["userId"] = this.userId;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateLandlordDto {
    propertyId?: string;
    userId?: string | undefined;
    email?: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    propertyId?: string;
    userId?: string | undefined;
    email?: string | undefined;
    toTime?: Date;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.toTime = _data["toTime"] ? new Date(_data["toTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["toTime"] = this.toTime ? this.toTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateTenantDto {
    propertyId?: string;
    userId?: string | undefined;
    email?: string | undefined;
    toTime?: Date;
}

export class UseVerifyCodeDto implements IUseVerifyCodeDto {
    email?: string | undefined;
    verifyCode?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IUseVerifyCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.verifyCode = _data["verifyCode"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UseVerifyCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UseVerifyCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["verifyCode"] = this.verifyCode;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUseVerifyCodeDto {
    email?: string | undefined;
    verifyCode?: string | undefined;
    userId?: string | undefined;
}

export class PropertyFilterDto implements IPropertyFilterDto {
    pageNumber?: number;
    pageSize?: number;
    propertyTitle?: string | undefined;
    listPropertyType?: string[] | undefined;
    listTransactionType?: PropertyTransactionType[] | undefined;
    listStatus?: PropertyStatus[] | undefined;

    constructor(data?: IPropertyFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.propertyTitle = _data["propertyTitle"];
            if (Array.isArray(_data["listPropertyType"])) {
                this.listPropertyType = [] as any;
                for (let item of _data["listPropertyType"])
                    this.listPropertyType!.push(item);
            }
            if (Array.isArray(_data["listTransactionType"])) {
                this.listTransactionType = [] as any;
                for (let item of _data["listTransactionType"])
                    this.listTransactionType!.push(item);
            }
            if (Array.isArray(_data["listStatus"])) {
                this.listStatus = [] as any;
                for (let item of _data["listStatus"])
                    this.listStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): PropertyFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["propertyTitle"] = this.propertyTitle;
        if (Array.isArray(this.listPropertyType)) {
            data["listPropertyType"] = [];
            for (let item of this.listPropertyType)
                data["listPropertyType"].push(item);
        }
        if (Array.isArray(this.listTransactionType)) {
            data["listTransactionType"] = [];
            for (let item of this.listTransactionType)
                data["listTransactionType"].push(item);
        }
        if (Array.isArray(this.listStatus)) {
            data["listStatus"] = [];
            for (let item of this.listStatus)
                data["listStatus"].push(item);
        }
        return data;
    }
}

export interface IPropertyFilterDto {
    pageNumber?: number;
    pageSize?: number;
    propertyTitle?: string | undefined;
    listPropertyType?: string[] | undefined;
    listTransactionType?: PropertyTransactionType[] | undefined;
    listStatus?: PropertyStatus[] | undefined;
}

export class SocialNetworkDto extends AuditableEntity implements ISocialNetworkDto {
    id?: string;
    name?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    socialNetworkTypeName?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: ISocialNetworkDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.linkUrl = _data["linkUrl"];
            this.socialNetworkTypeId = _data["socialNetworkTypeId"];
            this.socialNetworkTypeName = _data["socialNetworkTypeName"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): SocialNetworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["linkUrl"] = this.linkUrl;
        data["socialNetworkTypeId"] = this.socialNetworkTypeId;
        data["socialNetworkTypeName"] = this.socialNetworkTypeName;
        data["descriptions"] = this.descriptions;
        super.toJSON(data);
        return data;
    }
}

export interface ISocialNetworkDto extends IAuditableEntity {
    id?: string;
    name?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    socialNetworkTypeName?: string | undefined;
    descriptions?: string | undefined;
}

export class CreateSocialNetworkDto implements ICreateSocialNetworkDto {
    name?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: ICreateSocialNetworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imageUrl = _data["imageUrl"];
            this.imagePath = _data["imagePath"];
            this.linkUrl = _data["linkUrl"];
            this.socialNetworkTypeId = _data["socialNetworkTypeId"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): CreateSocialNetworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSocialNetworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["imagePath"] = this.imagePath;
        data["linkUrl"] = this.linkUrl;
        data["socialNetworkTypeId"] = this.socialNetworkTypeId;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface ICreateSocialNetworkDto {
    name?: string | undefined;
    imageUrl?: string | undefined;
    imagePath?: string | undefined;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    descriptions?: string | undefined;
}

export class SocialNetworkTypeDto implements ISocialNetworkTypeDto {
    id?: string;
    name?: string | undefined;
    type?: SocialNetworkTypesEnum;
    descriptions?: string | undefined;

    constructor(data?: ISocialNetworkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): SocialNetworkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface ISocialNetworkTypeDto {
    id?: string;
    name?: string | undefined;
    type?: SocialNetworkTypesEnum;
    descriptions?: string | undefined;
}

export enum SocialNetworkTypesEnum {
    Facebook = 1,
    Youtube = 2,
    Twitter = 3,
    Zalo = 4,
    Instagram = 5,
}

export class UserInfo implements IUserInfo {
    userId?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    listRole?: string[] | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            if (Array.isArray(_data["listRole"])) {
                this.listRole = [] as any;
                for (let item of _data["listRole"])
                    this.listRole!.push(item);
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        if (Array.isArray(this.listRole)) {
            data["listRole"] = [];
            for (let item of this.listRole)
                data["listRole"].push(item);
        }
        return data;
    }
}

export interface IUserInfo {
    userId?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    listRole?: string[] | undefined;
}

export class VideoDto implements IVideoDto {
    id?: string;
    title?: string | undefined;
    link?: string | undefined;
    orginalLink?: string | undefined;
    tags?: string | undefined;
    isHighlight?: boolean;
    isActive?: boolean;
    description?: string | undefined;
    videoCategoryId?: string | undefined;
    videoCategory?: MasterDataDto | undefined;
    created?: Date;

    constructor(data?: IVideoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.link = _data["link"];
            this.orginalLink = _data["orginalLink"];
            this.tags = _data["tags"];
            this.isHighlight = _data["isHighlight"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.videoCategoryId = _data["videoCategoryId"];
            this.videoCategory = _data["videoCategory"] ? MasterDataDto.fromJS(_data["videoCategory"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VideoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["link"] = this.link;
        data["orginalLink"] = this.orginalLink;
        data["tags"] = this.tags;
        data["isHighlight"] = this.isHighlight;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["videoCategoryId"] = this.videoCategoryId;
        data["videoCategory"] = this.videoCategory ? this.videoCategory.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVideoDto {
    id?: string;
    title?: string | undefined;
    link?: string | undefined;
    orginalLink?: string | undefined;
    tags?: string | undefined;
    isHighlight?: boolean;
    isActive?: boolean;
    description?: string | undefined;
    videoCategoryId?: string | undefined;
    videoCategory?: MasterDataDto | undefined;
    created?: Date;
}

export class PaginatedListOfVideoDto implements IPaginatedListOfVideoDto {
    items?: VideoDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfVideoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VideoDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfVideoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVideoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfVideoDto {
    items?: VideoDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class FilterVideoDto implements IFilterVideoDto {
    pageNumber?: number;
    pageSize?: number;
    title?: string | undefined;
    videoCategoryId?: string | undefined;
    highlight?: boolean;

    constructor(data?: IFilterVideoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.title = _data["title"];
            this.videoCategoryId = _data["videoCategoryId"];
            this.highlight = _data["highlight"];
        }
    }

    static fromJS(data: any): FilterVideoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterVideoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["title"] = this.title;
        data["videoCategoryId"] = this.videoCategoryId;
        data["highlight"] = this.highlight;
        return data;
    }
}

export interface IFilterVideoDto {
    pageNumber?: number;
    pageSize?: number;
    title?: string | undefined;
    videoCategoryId?: string | undefined;
    highlight?: boolean;
}

export class CreateVideoDto implements ICreateVideoDto {
    title?: string | undefined;
    link?: string | undefined;
    orginalLink?: string | undefined;
    tags?: string | undefined;
    isHighlight?: boolean;
    isActive?: boolean;
    description?: string | undefined;
    videoCategoryId?: string | undefined;

    constructor(data?: ICreateVideoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.link = _data["link"];
            this.orginalLink = _data["orginalLink"];
            this.tags = _data["tags"];
            this.isHighlight = _data["isHighlight"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.videoCategoryId = _data["videoCategoryId"];
        }
    }

    static fromJS(data: any): CreateVideoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVideoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["orginalLink"] = this.orginalLink;
        data["tags"] = this.tags;
        data["isHighlight"] = this.isHighlight;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["videoCategoryId"] = this.videoCategoryId;
        return data;
    }
}

export interface ICreateVideoDto {
    title?: string | undefined;
    link?: string | undefined;
    orginalLink?: string | undefined;
    tags?: string | undefined;
    isHighlight?: boolean;
    isActive?: boolean;
    description?: string | undefined;
    videoCategoryId?: string | undefined;
}

export class FilterWebsitePropertyDto implements IFilterWebsitePropertyDto {
    pageNumber?: number;
    pageSize?: number;
    propertyTitle?: string | undefined;
    location?: string | undefined;
    numberOfBedRooms?: number | undefined;
    numberOfBathRooms?: number | undefined;
    priceRangeFrom?: number | undefined;
    priceRangeTo?: number | undefined;
    areaFrom?: number | undefined;
    areaTo?: number | undefined;
    orderByTitle?: number;
    orderByPrice?: number;
    isFeatured?: boolean | undefined;
    listTags?: string[] | undefined;
    listPropertyType?: string[] | undefined;
    listTransactionType?: PropertyTransactionType[] | undefined;

    constructor(data?: IFilterWebsitePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.propertyTitle = _data["propertyTitle"];
            this.location = _data["location"];
            this.numberOfBedRooms = _data["numberOfBedRooms"];
            this.numberOfBathRooms = _data["numberOfBathRooms"];
            this.priceRangeFrom = _data["priceRangeFrom"];
            this.priceRangeTo = _data["priceRangeTo"];
            this.areaFrom = _data["areaFrom"];
            this.areaTo = _data["areaTo"];
            this.orderByTitle = _data["orderByTitle"];
            this.orderByPrice = _data["orderByPrice"];
            this.isFeatured = _data["isFeatured"];
            if (Array.isArray(_data["listTags"])) {
                this.listTags = [] as any;
                for (let item of _data["listTags"])
                    this.listTags!.push(item);
            }
            if (Array.isArray(_data["listPropertyType"])) {
                this.listPropertyType = [] as any;
                for (let item of _data["listPropertyType"])
                    this.listPropertyType!.push(item);
            }
            if (Array.isArray(_data["listTransactionType"])) {
                this.listTransactionType = [] as any;
                for (let item of _data["listTransactionType"])
                    this.listTransactionType!.push(item);
            }
        }
    }

    static fromJS(data: any): FilterWebsitePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterWebsitePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["propertyTitle"] = this.propertyTitle;
        data["location"] = this.location;
        data["numberOfBedRooms"] = this.numberOfBedRooms;
        data["numberOfBathRooms"] = this.numberOfBathRooms;
        data["priceRangeFrom"] = this.priceRangeFrom;
        data["priceRangeTo"] = this.priceRangeTo;
        data["areaFrom"] = this.areaFrom;
        data["areaTo"] = this.areaTo;
        data["orderByTitle"] = this.orderByTitle;
        data["orderByPrice"] = this.orderByPrice;
        data["isFeatured"] = this.isFeatured;
        if (Array.isArray(this.listTags)) {
            data["listTags"] = [];
            for (let item of this.listTags)
                data["listTags"].push(item);
        }
        if (Array.isArray(this.listPropertyType)) {
            data["listPropertyType"] = [];
            for (let item of this.listPropertyType)
                data["listPropertyType"].push(item);
        }
        if (Array.isArray(this.listTransactionType)) {
            data["listTransactionType"] = [];
            for (let item of this.listTransactionType)
                data["listTransactionType"].push(item);
        }
        return data;
    }
}

export interface IFilterWebsitePropertyDto {
    pageNumber?: number;
    pageSize?: number;
    propertyTitle?: string | undefined;
    location?: string | undefined;
    numberOfBedRooms?: number | undefined;
    numberOfBathRooms?: number | undefined;
    priceRangeFrom?: number | undefined;
    priceRangeTo?: number | undefined;
    areaFrom?: number | undefined;
    areaTo?: number | undefined;
    orderByTitle?: number;
    orderByPrice?: number;
    isFeatured?: boolean | undefined;
    listTags?: string[] | undefined;
    listPropertyType?: string[] | undefined;
    listTransactionType?: PropertyTransactionType[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}