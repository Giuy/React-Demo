//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { BaseClient } from './base-client';import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class GeneralClient extends BaseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    activityCategories_GetActivityCategories(  cancelToken?: CancelToken | undefined): Promise<ActivityCategoryDto[]> {
        let url_ = this.baseUrl + "/api/activitycategories/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_GetActivityCategories(_response));
        });
    }

    protected processActivityCategories_GetActivityCategories(response: AxiosResponse): Promise<ActivityCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityCategoryDto[]>(null as any);
    }

    activityCategories_GetActivityCategory(id: string , cancelToken?: CancelToken | undefined): Promise<ActivityCategoryDto> {
        let url_ = this.baseUrl + "/api/activitycategories/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_GetActivityCategory(_response));
        });
    }

    protected processActivityCategories_GetActivityCategory(response: AxiosResponse): Promise<ActivityCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActivityCategoryDto.fromJS(resultData200);
            return Promise.resolve<ActivityCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ActivityCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityCategoryDto>(null as any);
    }

    activityCategories_PutActivityCategory(id: string | undefined, model: CreateActivityCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activitycategories/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_PutActivityCategory(_response));
        });
    }

    protected processActivityCategories_PutActivityCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateActivityCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activityCategories_PostActivityCategory(model: CreateActivityCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activitycategories/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_PostActivityCategory(_response));
        });
    }

    protected processActivityCategories_PostActivityCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ActivityCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activityCategories_DeleteActivityCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activitycategories/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_DeleteActivityCategory(_response));
        });
    }

    protected processActivityCategories_DeleteActivityCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activityCategories_GetActivityCategoriesByIndustry(industry: IndustryEnum | undefined , cancelToken?: CancelToken | undefined): Promise<ActivityCategoryDto[]> {
        let url_ = this.baseUrl + "/api/activitycategories/getbyindustry?";
        if (industry === null)
            throw new Error("The parameter 'industry' cannot be null.");
        else if (industry !== undefined)
            url_ += "industry=" + encodeURIComponent("" + industry) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_GetActivityCategoriesByIndustry(_response));
        });
    }

    protected processActivityCategories_GetActivityCategoriesByIndustry(response: AxiosResponse): Promise<ActivityCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityCategoryDto[]>(null as any);
    }

    activityCategories_GetActivityCategoriesForAdmin(  cancelToken?: CancelToken | undefined): Promise<ActivityCategoryDto[]> {
        let url_ = this.baseUrl + "/api/activitycategories/getallforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_GetActivityCategoriesForAdmin(_response));
        });
    }

    protected processActivityCategories_GetActivityCategoriesForAdmin(response: AxiosResponse): Promise<ActivityCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityCategoryDto[]>(null as any);
    }

    activityCategories_GetActivityCategoryForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<ActivityCategoryDto> {
        let url_ = this.baseUrl + "/api/activitycategories/detailsforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivityCategories_GetActivityCategoryForAdmin(_response));
        });
    }

    protected processActivityCategories_GetActivityCategoryForAdmin(response: AxiosResponse): Promise<ActivityCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActivityCategoryDto.fromJS(resultData200);
            return Promise.resolve<ActivityCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ActivityCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityCategoryDto>(null as any);
    }

    activity_GetActivities(  cancelToken?: CancelToken | undefined): Promise<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/activity/getallactivities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_GetActivities(_response));
        });
    }

    protected processActivity_GetActivities(response: AxiosResponse): Promise<ActivityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityDto[]>(null as any);
    }

    activity_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<ActivityDto> {
        let url_ = this.baseUrl + "/api/activity/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_GetNewCategory(_response));
        });
    }

    protected processActivity_GetNewCategory(response: AxiosResponse): Promise<ActivityDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActivityDto.fromJS(resultData200);
            return Promise.resolve<ActivityDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ActivityDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityDto>(null as any);
    }

    activity_PutNewCategory(id: string | undefined, model: CreateActivityDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activity/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_PutNewCategory(_response));
        });
    }

    protected processActivity_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateActivityDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activity_PostNewCategory(model: CreateActivityDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activity/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_PostNewCategory(_response));
        });
    }

    protected processActivity_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ActivityDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activity_DeleteNewCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/activity/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_DeleteNewCategory(_response));
        });
    }

    protected processActivity_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    activity_GetActivitiesByCategory(categoryId: string , cancelToken?: CancelToken | undefined): Promise<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/activity/getactivitiesbycategoryid/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_GetActivitiesByCategory(_response));
        });
    }

    protected processActivity_GetActivitiesByCategory(response: AxiosResponse): Promise<ActivityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityDto[]>(null as any);
    }

    activity_SearchingCategory(model: SearchingActivityDto , cancelToken?: CancelToken | undefined): Promise<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/activity/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_SearchingCategory(_response));
        });
    }

    protected processActivity_SearchingCategory(response: AxiosResponse): Promise<ActivityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ActivityDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ActivityDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityDto[]>(null as any);
    }

    activity_GetActivitiesForAdmin(  cancelToken?: CancelToken | undefined): Promise<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/activity/getallforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processActivity_GetActivitiesForAdmin(_response));
        });
    }

    protected processActivity_GetActivitiesForAdmin(response: AxiosResponse): Promise<ActivityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ActivityDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActivityDto[]>(null as any);
    }

    admin_CheckAdminCanAccess(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CheckAdminCanAccess(_response));
        });
    }

    protected processAdmin_CheckAdminCanAccess(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    admin_RetriveAllUsers(  cancelToken?: CancelToken | undefined): Promise<UserResult[]> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_RetriveAllUsers(_response));
        });
    }

    protected processAdmin_RetriveAllUsers(response: AxiosResponse): Promise<UserResult[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserResult[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult[]>(null as any);
    }

    admin_LockUser(request: LockRequest , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_LockUser(_response));
        });
    }

    protected processAdmin_LockUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_UnlockUser(request: LockRequest , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_UnlockUser(_response));
        });
    }

    protected processAdmin_UnlockUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_GetAttachmentsByType(attachmentType: AttachmentType , cancelToken?: CancelToken | undefined): Promise<AttachmentDto[]> {
        let url_ = this.baseUrl + "/api/attachments/{attachmentType}";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_GetAttachmentsByType(_response));
        });
    }

    protected processAttachments_GetAttachmentsByType(response: AxiosResponse): Promise<AttachmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentDto[]>(null as any);
    }

    attachments_AddAttachment(attachmentType: AttachmentType, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/{attachmentType}";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_AddAttachment(_response));
        });
    }

    protected processAttachments_AddAttachment(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_GetByListAttachmentType(listAttachmentType: AttachmentType[] , cancelToken?: CancelToken | undefined): Promise<AttachmentDto[]> {
        let url_ = this.baseUrl + "/api/attachments/getbylistattachmenttype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listAttachmentType);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_GetByListAttachmentType(_response));
        });
    }

    protected processAttachments_GetByListAttachmentType(response: AxiosResponse): Promise<AttachmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentDto[]>(null as any);
    }

    attachments_DeleteAttachments(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_DeleteAttachments(_response));
        });
    }

    protected processAttachments_DeleteAttachments(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_BulkDelete(items: string[] , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/bulkdeleteattachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_BulkDelete(_response));
        });
    }

    protected processAttachments_BulkDelete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_UpdateAttachmentInfo(updateDto: UpdateAttachmentInfoDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/attachments/updateattachmentinfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_UpdateAttachmentInfo(_response));
        });
    }

    protected processAttachments_UpdateAttachmentInfo(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachments_AddAttachments(attachmentType: AttachmentType, models: UploadFileModel[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result[]> {
        let url_ = this.baseUrl + "/api/attachments/multiples/{attachmentType}";
        if (attachmentType === undefined || attachmentType === null)
            throw new Error("The parameter 'attachmentType' must be defined.");
        url_ = url_.replace("{attachmentType}", encodeURIComponent("" + attachmentType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (models !== null && models !== undefined)
            models.forEach(item_ => content_.append("models", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachments_AddAttachments(_response));
        });
    }

    protected processAttachments_AddAttachments(response: AxiosResponse): Promise<Result[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Result.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Result[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result[]>(null as any);
    }

    banner_GetBanners(  cancelToken?: CancelToken | undefined): Promise<BannerDto[]> {
        let url_ = this.baseUrl + "/api/banner/getallbanner";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetBanners(_response));
        });
    }

    protected processBanner_GetBanners(response: AxiosResponse): Promise<BannerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BannerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BannerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerDto[]>(null as any);
    }

    banner_GetBanner(id: string , cancelToken?: CancelToken | undefined): Promise<BannerDto> {
        let url_ = this.baseUrl + "/api/banner/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetBanner(_response));
        });
    }

    protected processBanner_GetBanner(response: AxiosResponse): Promise<BannerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BannerDto.fromJS(resultData200);
            return Promise.resolve<BannerDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = BannerDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerDto>(null as any);
    }

    banner_PutBanner(id: string | undefined, model: CreateBannerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_PutBanner(_response));
        });
    }

    protected processBanner_PutBanner(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateBannerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_PostBanner(model: CreateBannerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_PostBanner(_response));
        });
    }

    protected processBanner_PostBanner(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = BannerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_DeleteBanner(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_DeleteBanner(_response));
        });
    }

    protected processBanner_DeleteBanner(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_GetBannerByType(bannerType: number , cancelToken?: CancelToken | undefined): Promise<BannerDto[]> {
        let url_ = this.baseUrl + "/api/banner/getbannerbytype/{bannerType}";
        if (bannerType === undefined || bannerType === null)
            throw new Error("The parameter 'bannerType' must be defined.");
        url_ = url_.replace("{bannerType}", encodeURIComponent("" + bannerType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetBannerByType(_response));
        });
    }

    protected processBanner_GetBannerByType(response: AxiosResponse): Promise<BannerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BannerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BannerDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(BannerDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerDto[]>(null as any);
    }

    banner_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/banner/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_UploadImage(_response));
        });
    }

    protected processBanner_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    banner_GetBannersForAdmin(  cancelToken?: CancelToken | undefined): Promise<BannerDto[]> {
        let url_ = this.baseUrl + "/api/banner/getallbannerforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetBannersForAdmin(_response));
        });
    }

    protected processBanner_GetBannersForAdmin(response: AxiosResponse): Promise<BannerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BannerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BannerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerDto[]>(null as any);
    }

    commonConfig_GetCommonConfigs(  cancelToken?: CancelToken | undefined): Promise<CommonConfigDto> {
        let url_ = this.baseUrl + "/api/commonconfig/getcommonconfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonConfig_GetCommonConfigs(_response));
        });
    }

    protected processCommonConfig_GetCommonConfigs(response: AxiosResponse): Promise<CommonConfigDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommonConfigDto.fromJS(resultData200);
            return Promise.resolve<CommonConfigDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommonConfigDto>(null as any);
    }

    commonConfig_PostCommonConfig(model: CreateCommonConfigDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/commonconfig/command";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonConfig_PostCommonConfig(_response));
        });
    }

    protected processCommonConfig_PostCommonConfig(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CommonConfigDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    commonConfig_UploadApplyTemplate(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/commonconfig/uploadapplytemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommonConfig_UploadApplyTemplate(_response));
        });
    }

    protected processCommonConfig_UploadApplyTemplate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    contactCustomer_GetContactCustomer(  cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto[]> {
        let url_ = this.baseUrl + "/api/contactcustomer/getallcontactcustomer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_GetContactCustomer(_response));
        });
    }

    protected processContactCustomer_GetContactCustomer(response: AxiosResponse): Promise<ContactCustomerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactCustomerDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto[]>(null as any);
    }

    contactCustomer_GetNew(id: string , cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto> {
        let url_ = this.baseUrl + "/api/contactcustomer/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_GetNew(_response));
        });
    }

    protected processContactCustomer_GetNew(response: AxiosResponse): Promise<ContactCustomerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContactCustomerDto.fromJS(resultData200);
            return Promise.resolve<ContactCustomerDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ContactCustomerDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto>(null as any);
    }

    contactCustomer_PutNew(id: string | undefined, model: CreateContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_PutNew(_response));
        });
    }

    protected processContactCustomer_PutNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ContactCustomerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_PostNew(model: CreateContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_PostNew(_response));
        });
    }

    protected processContactCustomer_PostNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ContactCustomerDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_DeleteNew(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactcustomer/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_DeleteNew(_response));
        });
    }

    protected processContactCustomer_DeleteNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactCustomer_SearchingContactCustomer(model: SearchingContactCustomerDto , cancelToken?: CancelToken | undefined): Promise<ContactCustomerDto[]> {
        let url_ = this.baseUrl + "/api/contactcustomer/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_SearchingContactCustomer(_response));
        });
    }

    protected processContactCustomer_SearchingContactCustomer(response: AxiosResponse): Promise<ContactCustomerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactCustomerDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ContactCustomerDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactCustomerDto[]>(null as any);
    }

    contactCustomer_UploadCV(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/contactcustomer/uploadcv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactCustomer_UploadCV(_response));
        });
    }

    protected processContactCustomer_UploadCV(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    contactEmail_GetContactEmails(  cancelToken?: CancelToken | undefined): Promise<ContactEmailDto[]> {
        let url_ = this.baseUrl + "/api/contactemail/getallcontactemail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactEmail_GetContactEmails(_response));
        });
    }

    protected processContactEmail_GetContactEmails(response: AxiosResponse): Promise<ContactEmailDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactEmailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactEmailDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactEmailDto[]>(null as any);
    }

    contactEmail_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<ContactEmailDto> {
        let url_ = this.baseUrl + "/api/contactemail/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactEmail_GetNewCategory(_response));
        });
    }

    protected processContactEmail_GetNewCategory(response: AxiosResponse): Promise<ContactEmailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContactEmailDto.fromJS(resultData200);
            return Promise.resolve<ContactEmailDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ContactEmailDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactEmailDto>(null as any);
    }

    contactEmail_PutNewCategory(id: string | undefined, model: CreateContactEmailDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactemail/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactEmail_PutNewCategory(_response));
        });
    }

    protected processContactEmail_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateContactEmailDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactEmail_PostNewCategory(model: CreateContactEmailDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactemail/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactEmail_PostNewCategory(_response));
        });
    }

    protected processContactEmail_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ContactEmailDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contactEmail_DeleteNewCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contactemail/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContactEmail_DeleteNewCategory(_response));
        });
    }

    protected processContactEmail_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    emailNotification_SendContactEmail(model: ContactClientDto , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/emailnotification/sendcontactemail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEmailNotification_SendContactEmail(_response));
        });
    }

    protected processEmailNotification_SendContactEmail(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    health_Health(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processHealth_Health(_response));
        });
    }

    protected processHealth_Health(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    newCategories_GetNewCategories(  cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto[]> {
        let url_ = this.baseUrl + "/api/newcategories/getallnewscategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategories(_response));
        });
    }

    protected processNewCategories_GetNewCategories(response: AxiosResponse): Promise<NewsCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto[]>(null as any);
    }

    newCategories_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto> {
        let url_ = this.baseUrl + "/api/newcategories/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategory(_response));
        });
    }

    protected processNewCategories_GetNewCategory(response: AxiosResponse): Promise<NewsCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryDto.fromJS(resultData200);
            return Promise.resolve<NewsCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto>(null as any);
    }

    newCategories_PutNewCategory(id: string | undefined, model: CreateNewsCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_PutNewCategory(_response));
        });
    }

    protected processNewCategories_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNewsCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_PostNewCategory(model: CreateNewsCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_PostNewCategory(_response));
        });
    }

    protected processNewCategories_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_DeleteNewCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newcategories/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_DeleteNewCategory(_response));
        });
    }

    protected processNewCategories_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newCategories_GetNewCategoriesForAdmin(  cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto[]> {
        let url_ = this.baseUrl + "/api/newcategories/getallnewscategoryforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategoriesForAdmin(_response));
        });
    }

    protected processNewCategories_GetNewCategoriesForAdmin(response: AxiosResponse): Promise<NewsCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto[]>(null as any);
    }

    newCategories_GetNewCategoryForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<NewsCategoryDto> {
        let url_ = this.baseUrl + "/api/newcategories/detailsforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewCategories_GetNewCategoryForAdmin(_response));
        });
    }

    protected processNewCategories_GetNewCategoryForAdmin(response: AxiosResponse): Promise<NewsCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryDto.fromJS(resultData200);
            return Promise.resolve<NewsCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryDto>(null as any);
    }

    news_GetNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getallnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNews(_response));
        });
    }

    protected processNews_GetNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetTopNews(number: number , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/top/{number}";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetTopNews(_response));
        });
    }

    protected processNews_GetTopNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetFeaturedNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getfeaturednews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetFeaturedNews(_response));
        });
    }

    protected processNews_GetFeaturedNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetHomeViewNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/gethomeviewnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetHomeViewNews(_response));
        });
    }

    protected processNews_GetHomeViewNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNormalNews(  cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getnormalnews";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNormalNews(_response));
        });
    }

    protected processNews_GetNormalNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNew(id: string , cancelToken?: CancelToken | undefined): Promise<NewsDto> {
        let url_ = this.baseUrl + "/api/news/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNew(_response));
        });
    }

    protected processNews_GetNew(response: AxiosResponse): Promise<NewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsDto.fromJS(resultData200);
            return Promise.resolve<NewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto>(null as any);
    }

    news_PutNew(id: string | undefined, model: CreateNewsDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_PutNew(_response));
        });
    }

    protected processNews_PutNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_PostNew(model: CreateNewsDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_PostNew(_response));
        });
    }

    protected processNews_PostNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = NewsDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_DeleteNew(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_DeleteNew(_response));
        });
    }

    protected processNews_DeleteNew(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_SearchingNews(model: SearchingNewsDto , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_SearchingNews(_response));
        });
    }

    protected processNews_SearchingNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(NewsDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetByCategoryNews(categoryId: string , cancelToken?: CancelToken | undefined): Promise<NewsDto[]> {
        let url_ = this.baseUrl + "/api/news/getnewsbycategory/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetByCategoryNews(_response));
        });
    }

    protected processNews_GetByCategoryNews(response: AxiosResponse): Promise<NewsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsDto[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(NewsDto.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto[]>(null as any);
    }

    news_GetNewForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<NewsDto> {
        let url_ = this.baseUrl + "/api/news/detailforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNewForAdmin(_response));
        });
    }

    protected processNews_GetNewForAdmin(response: AxiosResponse): Promise<NewsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsDto.fromJS(resultData200);
            return Promise.resolve<NewsDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = NewsDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsDto>(null as any);
    }

    news_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/news/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_UploadImage(_response));
        });
    }

    protected processNews_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    photo_GetPhotos(  cancelToken?: CancelToken | undefined): Promise<PhotoDto[]> {
        let url_ = this.baseUrl + "/api/photo/getphotos";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetPhotos(_response));
        });
    }

    protected processPhoto_GetPhotos(response: AxiosResponse): Promise<PhotoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PhotoDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotoDto[]>(null as any);
    }

    photo_GetPhoto(id: string , cancelToken?: CancelToken | undefined): Promise<PhotoDto> {
        let url_ = this.baseUrl + "/api/photo/getphotos/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetPhoto(_response));
        });
    }

    protected processPhoto_GetPhoto(response: AxiosResponse): Promise<PhotoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PhotoDto.fromJS(resultData200);
            return Promise.resolve<PhotoDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PhotoDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotoDto>(null as any);
    }

    photo_PutPhoto(id: string, entity: PhotoDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/putphoto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PutPhoto(_response));
        });
    }

    protected processPhoto_PutPhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PhotoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_PostPhoto(model: PhotoDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/postphoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PostPhoto(_response));
        });
    }

    protected processPhoto_PostPhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PhotoDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_DeletePhoto(id: string , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/photo/deletephoto/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_DeletePhoto(_response));
        });
    }

    protected processPhoto_DeletePhoto(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    photo_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/photo/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_UploadImage(_response));
        });
    }

    protected processPhoto_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    prize_GetPrizes(  cancelToken?: CancelToken | undefined): Promise<PrizeDto[]> {
        let url_ = this.baseUrl + "/api/prize/getallprize";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_GetPrizes(_response));
        });
    }

    protected processPrize_GetPrizes(response: AxiosResponse): Promise<PrizeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrizeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PrizeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrizeDto[]>(null as any);
    }

    prize_GetPrize(id: string , cancelToken?: CancelToken | undefined): Promise<PrizeDto> {
        let url_ = this.baseUrl + "/api/prize/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_GetPrize(_response));
        });
    }

    protected processPrize_GetPrize(response: AxiosResponse): Promise<PrizeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PrizeDto.fromJS(resultData200);
            return Promise.resolve<PrizeDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = PrizeDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrizeDto>(null as any);
    }

    prize_PutPrize(id: string | undefined, model: CreatePrizeDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/prize/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_PutPrize(_response));
        });
    }

    protected processPrize_PutPrize(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreatePrizeDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    prize_PostPrize(model: CreatePrizeDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/prize/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_PostPrize(_response));
        });
    }

    protected processPrize_PostPrize(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PrizeDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    prize_DeletePrize(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/prize/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_DeletePrize(_response));
        });
    }

    protected processPrize_DeletePrize(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    prize_UploadImage(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/prize/uploadimage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_UploadImage(_response));
        });
    }

    protected processPrize_UploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    prize_GetPrizesForAdmin(  cancelToken?: CancelToken | undefined): Promise<PrizeDto[]> {
        let url_ = this.baseUrl + "/api/prize/getallprizeforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPrize_GetPrizesForAdmin(_response));
        });
    }

    protected processPrize_GetPrizesForAdmin(response: AxiosResponse): Promise<PrizeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrizeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PrizeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrizeDto[]>(null as any);
    }

    profile_ChangePassword(request: ChangePasswordRequest , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_ChangePassword(_response));
        });
    }

    protected processProfile_ChangePassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_ForgetPassword(request: ForgetPasswordRequest , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/profile/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_ForgetPassword(_response));
        });
    }

    protected processProfile_ForgetPassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_UserInfo(  cancelToken?: CancelToken | undefined): Promise<UserResult> {
        let url_ = this.baseUrl + "/api/profile/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_UserInfo(_response));
        });
    }

    protected processProfile_UserInfo(response: AxiosResponse): Promise<UserResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResult.fromJS(resultData200);
            return Promise.resolve<UserResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult>(null as any);
    }

    recruitmentCategories_GetRecruitmentCategories(  cancelToken?: CancelToken | undefined): Promise<RecruitmentCategoryDto[]> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/getallrecruitmentcategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_GetRecruitmentCategories(_response));
        });
    }

    protected processRecruitmentCategories_GetRecruitmentCategories(response: AxiosResponse): Promise<RecruitmentCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecruitmentCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RecruitmentCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentCategoryDto[]>(null as any);
    }

    recruitmentCategories_GetRecruitmentCategory(id: string , cancelToken?: CancelToken | undefined): Promise<RecruitmentCategoryDto> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_GetRecruitmentCategory(_response));
        });
    }

    protected processRecruitmentCategories_GetRecruitmentCategory(response: AxiosResponse): Promise<RecruitmentCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RecruitmentCategoryDto.fromJS(resultData200);
            return Promise.resolve<RecruitmentCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RecruitmentCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentCategoryDto>(null as any);
    }

    recruitmentCategories_PutRecruitmentCategory(id: string | undefined, model: CreateRecruitmentCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_PutRecruitmentCategory(_response));
        });
    }

    protected processRecruitmentCategories_PutRecruitmentCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateRecruitmentCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitmentCategories_PostRecruitmentCategory(model: CreateRecruitmentCategoryDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_PostRecruitmentCategory(_response));
        });
    }

    protected processRecruitmentCategories_PostRecruitmentCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RecruitmentCategoryDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitmentCategories_DeleteRecruitmentCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_DeleteRecruitmentCategory(_response));
        });
    }

    protected processRecruitmentCategories_DeleteRecruitmentCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitmentCategories_GetRecruitmentCategoriesForAdmin(  cancelToken?: CancelToken | undefined): Promise<RecruitmentCategoryDto[]> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/getallrecruitmentcategoryforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_GetRecruitmentCategoriesForAdmin(_response));
        });
    }

    protected processRecruitmentCategories_GetRecruitmentCategoriesForAdmin(response: AxiosResponse): Promise<RecruitmentCategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecruitmentCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RecruitmentCategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentCategoryDto[]>(null as any);
    }

    recruitmentCategories_GetRecruitmentCategoryForAdmin(id: string , cancelToken?: CancelToken | undefined): Promise<RecruitmentCategoryDto> {
        let url_ = this.baseUrl + "/api/recruitmentcategories/detailsforadmin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitmentCategories_GetRecruitmentCategoryForAdmin(_response));
        });
    }

    protected processRecruitmentCategories_GetRecruitmentCategoryForAdmin(response: AxiosResponse): Promise<RecruitmentCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RecruitmentCategoryDto.fromJS(resultData200);
            return Promise.resolve<RecruitmentCategoryDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RecruitmentCategoryDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentCategoryDto>(null as any);
    }

    recruitment_GetRecruitments(  cancelToken?: CancelToken | undefined): Promise<RecruitmentDto[]> {
        let url_ = this.baseUrl + "/api/recruitment/getallrecruitment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_GetRecruitments(_response));
        });
    }

    protected processRecruitment_GetRecruitments(response: AxiosResponse): Promise<RecruitmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecruitmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RecruitmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentDto[]>(null as any);
    }

    recruitment_GetNewCategory(id: string , cancelToken?: CancelToken | undefined): Promise<RecruitmentDto> {
        let url_ = this.baseUrl + "/api/recruitment/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_GetNewCategory(_response));
        });
    }

    protected processRecruitment_GetNewCategory(response: AxiosResponse): Promise<RecruitmentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RecruitmentDto.fromJS(resultData200);
            return Promise.resolve<RecruitmentDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RecruitmentDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentDto>(null as any);
    }

    recruitment_PutNewCategory(id: string | undefined, model: CreateRecruitmentDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitment/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_PutNewCategory(_response));
        });
    }

    protected processRecruitment_PutNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateRecruitmentDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitment_PostNewCategory(model: CreateRecruitmentDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_PostNewCategory(_response));
        });
    }

    protected processRecruitment_PostNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RecruitmentDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitment_DeleteNewCategory(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/recruitment/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_DeleteNewCategory(_response));
        });
    }

    protected processRecruitment_DeleteNewCategory(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    recruitment_GetRecruitmentsByCategory(categoryId: string , cancelToken?: CancelToken | undefined): Promise<RecruitmentDto[]> {
        let url_ = this.baseUrl + "/api/recruitment/getrecruitmentsbycategory/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_GetRecruitmentsByCategory(_response));
        });
    }

    protected processRecruitment_GetRecruitmentsByCategory(response: AxiosResponse): Promise<RecruitmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecruitmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RecruitmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentDto[]>(null as any);
    }

    recruitment_GetRecruitmentsForAdmin(  cancelToken?: CancelToken | undefined): Promise<RecruitmentDto[]> {
        let url_ = this.baseUrl + "/api/recruitment/getallforadmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRecruitment_GetRecruitmentsForAdmin(_response));
        });
    }

    protected processRecruitment_GetRecruitmentsForAdmin(response: AxiosResponse): Promise<RecruitmentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecruitmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RecruitmentDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RecruitmentDto[]>(null as any);
    }

    socialNetwork_GetAllSocialNetworks(  cancelToken?: CancelToken | undefined): Promise<SocialNetworkDto[]> {
        let url_ = this.baseUrl + "/api/socialnetwork/getallsocialnetwork";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_GetAllSocialNetworks(_response));
        });
    }

    protected processSocialNetwork_GetAllSocialNetworks(response: AxiosResponse): Promise<SocialNetworkDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialNetworkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SocialNetworkDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkDto[]>(null as any);
    }

    socialNetwork_Details(id: string , cancelToken?: CancelToken | undefined): Promise<SocialNetworkDto> {
        let url_ = this.baseUrl + "/api/socialnetwork/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_Details(_response));
        });
    }

    protected processSocialNetwork_Details(response: AxiosResponse): Promise<SocialNetworkDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SocialNetworkDto.fromJS(resultData200);
            return Promise.resolve<SocialNetworkDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = SocialNetworkDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkDto>(null as any);
    }

    socialNetwork_PutSocialNetwork(id: string | undefined, model: CreateSocialNetworkDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_PutSocialNetwork(_response));
        });
    }

    protected processSocialNetwork_PutSocialNetwork(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateSocialNetworkDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_PostSocialNetwork(model: CreateSocialNetworkDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_PostSocialNetwork(_response));
        });
    }

    protected processSocialNetwork_PostSocialNetwork(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = SocialNetworkDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_DeleteSocialNetwork(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_DeleteSocialNetwork(_response));
        });
    }

    protected processSocialNetwork_DeleteSocialNetwork(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetworkType_GetAllSocialNetworkType(  cancelToken?: CancelToken | undefined): Promise<SocialNetworkTypeDto[]> {
        let url_ = this.baseUrl + "/api/socialnetworktype/getallsocialnetworktype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetworkType_GetAllSocialNetworkType(_response));
        });
    }

    protected processSocialNetworkType_GetAllSocialNetworkType(response: AxiosResponse): Promise<SocialNetworkTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialNetworkTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SocialNetworkTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkTypeDto[]>(null as any);
    }

    user_Login(request: LoginRequest , cancelToken?: CancelToken | undefined): Promise<LoginResult> {
        let url_ = this.baseUrl + "/api/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Login(_response));
        });
    }

    protected processUser_Login(response: AxiosResponse): Promise<LoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = LoginRequest.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResult.fromJS(resultData200);
            return Promise.resolve<LoginResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResult>(null as any);
    }

    user_Register(request: RegisterRequest , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Register(_response));
        });
    }

    protected processUser_Register(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    user_Logout(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Logout(_response));
        });
    }

    protected processUser_Logout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    user_RefreshToken(request: RefreshTokenRequest , cancelToken?: CancelToken | undefined): Promise<LoginResult> {
        let url_ = this.baseUrl + "/api/user/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_RefreshToken(_response));
        });
    }

    protected processUser_RefreshToken(response: AxiosResponse): Promise<LoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResult.fromJS(resultData200);
            return Promise.resolve<LoginResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResult>(null as any);
    }

    user_GetUserInfo(  cancelToken?: CancelToken | undefined): Promise<LoginResult> {
        let url_ = this.baseUrl + "/api/user/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_GetUserInfo(_response));
        });
    }

    protected processUser_GetUserInfo(response: AxiosResponse): Promise<LoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResult.fromJS(resultData200);
            return Promise.resolve<LoginResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResult>(null as any);
    }

    websiteBody_GetWebsiteBodyByType(type: WebsiteBodyTypesEnum , cancelToken?: CancelToken | undefined): Promise<WebsiteBodyMasterDto> {
        let url_ = this.baseUrl + "/api/websitebody/getwebsitebodybytype/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsiteBody_GetWebsiteBodyByType(_response));
        });
    }

    protected processWebsiteBody_GetWebsiteBodyByType(response: AxiosResponse): Promise<WebsiteBodyMasterDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WebsiteBodyMasterDto.fromJS(resultData200);
            return Promise.resolve<WebsiteBodyMasterDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = WebsiteBodyMasterDto.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WebsiteBodyMasterDto>(null as any);
    }

    websiteBody_PostWebsiteBodyMaster(createModel: CreateWebsiteBodyMasterDto , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/websitebody/postgetwebsitebody";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsiteBody_PostWebsiteBodyMaster(_response));
        });
    }

    protected processWebsiteBody_PostWebsiteBodyMaster(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateWebsiteBodyMasterDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    websiteBody_UploadAttachFile(file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/websitebody/uploadattachfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processWebsiteBody_UploadAttachFile(_response));
        });
    }

    protected processWebsiteBody_UploadAttachFile(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export abstract class AuditableEntity implements IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isDeleted?: DeletedStatus;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isDeleted?: DeletedStatus;
}

export class ActivityCategoryDto extends AuditableEntity implements IActivityCategoryDto {
    id?: string;
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    industry?: IndustryEnum;
    industryNameVi?: string | undefined;
    industryNameEn?: string | undefined;
    isActived?: boolean | undefined;

    constructor(data?: IActivityCategoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
            this.categoryNameEN = _data["categoryNameEN"];
            this.industry = _data["industry"];
            this.industryNameVi = _data["industryNameVi"];
            this.industryNameEn = _data["industryNameEn"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): ActivityCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        data["categoryNameEN"] = this.categoryNameEN;
        data["industry"] = this.industry;
        data["industryNameVi"] = this.industryNameVi;
        data["industryNameEn"] = this.industryNameEn;
        data["isActived"] = this.isActived;
        super.toJSON(data);
        return data;
    }
}

export interface IActivityCategoryDto extends IAuditableEntity {
    id?: string;
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    industry?: IndustryEnum;
    industryNameVi?: string | undefined;
    industryNameEn?: string | undefined;
    isActived?: boolean | undefined;
}

export enum IndustryEnum {
    DebtRecovery = 1,
    AssetAppraisalconsulting = 2,
    AssetManagementExploitation = 3,
    DebtAndAssetconsulting = 4,
}

export enum DeletedStatus {
    False = 1,
    True = 2,
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.objectReturn = _data["objectReturn"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["objectReturn"] = this.objectReturn;
        return data;
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;
}

export class CreateActivityCategoryDto implements ICreateActivityCategoryDto {
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    industry?: IndustryEnum;
    industryNameVi?: string | undefined;
    industryNameEn?: string | undefined;
    isActived?: boolean | undefined;

    constructor(data?: ICreateActivityCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            this.categoryNameEN = _data["categoryNameEN"];
            this.industry = _data["industry"];
            this.industryNameVi = _data["industryNameVi"];
            this.industryNameEn = _data["industryNameEn"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): CreateActivityCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        data["categoryNameEN"] = this.categoryNameEN;
        data["industry"] = this.industry;
        data["industryNameVi"] = this.industryNameVi;
        data["industryNameEn"] = this.industryNameEn;
        data["isActived"] = this.isActived;
        return data;
    }
}

export interface ICreateActivityCategoryDto {
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    industry?: IndustryEnum;
    industryNameVi?: string | undefined;
    industryNameEn?: string | undefined;
    isActived?: boolean | undefined;
}

export class ActivityDto extends AuditableEntity implements IActivityDto {
    id?: string;
    coverImage?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    activityCategoryId?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    keyword?: string | undefined;
    floors?: number | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    assetType?: string | undefined;
    contactCenter?: string | undefined;
    isActived?: boolean | undefined;
    activityCategory?: ActivityCategoryDto | undefined;

    constructor(data?: IActivityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.coverImage = _data["coverImage"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.activityCategoryId = _data["activityCategoryId"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.keyword = _data["keyword"];
            this.floors = _data["floors"];
            this.lotSize = _data["lotSize"];
            this.price = _data["price"];
            this.assetType = _data["assetType"];
            this.contactCenter = _data["contactCenter"];
            this.isActived = _data["isActived"];
            this.activityCategory = _data["activityCategory"] ? ActivityCategoryDto.fromJS(_data["activityCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverImage"] = this.coverImage;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["activityCategoryId"] = this.activityCategoryId;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["keyword"] = this.keyword;
        data["floors"] = this.floors;
        data["lotSize"] = this.lotSize;
        data["price"] = this.price;
        data["assetType"] = this.assetType;
        data["contactCenter"] = this.contactCenter;
        data["isActived"] = this.isActived;
        data["activityCategory"] = this.activityCategory ? this.activityCategory.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IActivityDto extends IAuditableEntity {
    id?: string;
    coverImage?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    activityCategoryId?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    keyword?: string | undefined;
    floors?: number | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    assetType?: string | undefined;
    contactCenter?: string | undefined;
    isActived?: boolean | undefined;
    activityCategory?: ActivityCategoryDto | undefined;
}

export class CreateActivityDto implements ICreateActivityDto {
    coverImage?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    activityCategoryId?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    keyword?: string | undefined;
    floors?: number | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    assetType?: string | undefined;
    contactCenter?: string | undefined;
    isActived?: boolean | undefined;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverImage = _data["coverImage"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.activityCategoryId = _data["activityCategoryId"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.keyword = _data["keyword"];
            this.floors = _data["floors"];
            this.lotSize = _data["lotSize"];
            this.price = _data["price"];
            this.assetType = _data["assetType"];
            this.contactCenter = _data["contactCenter"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverImage"] = this.coverImage;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["activityCategoryId"] = this.activityCategoryId;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["keyword"] = this.keyword;
        data["floors"] = this.floors;
        data["lotSize"] = this.lotSize;
        data["price"] = this.price;
        data["assetType"] = this.assetType;
        data["contactCenter"] = this.contactCenter;
        data["isActived"] = this.isActived;
        return data;
    }
}

export interface ICreateActivityDto {
    coverImage?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    activityCategoryId?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    keyword?: string | undefined;
    floors?: number | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    assetType?: string | undefined;
    contactCenter?: string | undefined;
    isActived?: boolean | undefined;
}

export class SearchingActivityDto implements ISearchingActivityDto {
    title?: string | undefined;
    isActived?: boolean | undefined;
    industry?: IndustryEnum | undefined;

    constructor(data?: ISearchingActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.isActived = _data["isActived"];
            this.industry = _data["industry"];
        }
    }

    static fromJS(data: any): SearchingActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isActived"] = this.isActived;
        data["industry"] = this.industry;
        return data;
    }
}

export interface ISearchingActivityDto {
    title?: string | undefined;
    isActived?: boolean | undefined;
    industry?: IndustryEnum | undefined;
}

export class UserResult implements IUserResult {
    phoneNumber?: string | undefined;
    email?: string | undefined;
    id?: string | undefined;

    constructor(data?: IUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserResult {
    phoneNumber?: string | undefined;
    email?: string | undefined;
    id?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = (<any>this.extensions)[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class LockRequest implements ILockRequest {
    userId!: string;

    constructor(data?: ILockRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): LockRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LockRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface ILockRequest {
    userId: string;
}

export class AttachmentDto implements IAttachmentDto {
    id?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    fileSizeInKb?: number;
    fileSizeInMb?: number;
    created?: Date;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
    attachmentType?: AttachmentType;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.filePath = _data["filePath"];
            this.fileUrl = _data["fileUrl"];
            this.fileSize = _data["fileSize"];
            this.fileSizeInKb = _data["fileSizeInKb"];
            this.fileSizeInMb = _data["fileSizeInMb"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.caption1 = _data["caption1"];
            this.caption2 = _data["caption2"];
            this.note = _data["note"];
            this.ordinal = _data["ordinal"];
            this.attachmentType = _data["attachmentType"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["filePath"] = this.filePath;
        data["fileUrl"] = this.fileUrl;
        data["fileSize"] = this.fileSize;
        data["fileSizeInKb"] = this.fileSizeInKb;
        data["fileSizeInMb"] = this.fileSizeInMb;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["caption1"] = this.caption1;
        data["caption2"] = this.caption2;
        data["note"] = this.note;
        data["ordinal"] = this.ordinal;
        data["attachmentType"] = this.attachmentType;
        return data;
    }
}

export interface IAttachmentDto {
    id?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    fileSizeInKb?: number;
    fileSizeInMb?: number;
    created?: Date;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
    attachmentType?: AttachmentType;
}

export enum AttachmentType {
    All = 0,
    Photo = 1,
    Video = 2,
    Excel = 3,
    Audio = 4,
    File3D = 5,
    Banner = 6,
    CommonConfig = 7,
    News = 8,
    Project = 9,
    Product = 10,
    WebsiteBody = 11,
}

export class UpdateAttachmentInfoDto implements IUpdateAttachmentInfoDto {
    id?: string;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;

    constructor(data?: IUpdateAttachmentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caption1 = _data["caption1"];
            this.caption2 = _data["caption2"];
            this.note = _data["note"];
            this.ordinal = _data["ordinal"];
        }
    }

    static fromJS(data: any): UpdateAttachmentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttachmentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caption1"] = this.caption1;
        data["caption2"] = this.caption2;
        data["note"] = this.note;
        data["ordinal"] = this.ordinal;
        return data;
    }
}

export interface IUpdateAttachmentInfoDto {
    id?: string;
    caption1?: string | undefined;
    caption2?: string | undefined;
    note?: string | undefined;
    ordinal?: number;
}

export class UploadFileModel implements IUploadFileModel {
    file?: string | undefined;

    constructor(data?: IUploadFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UploadFileModel {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data;
    }
}

export interface IUploadFileModel {
    file?: string | undefined;
}

export class BannerDto extends AuditableEntity implements IBannerDto {
    id?: string;
    imageUrl?: string | undefined;
    isActived?: boolean | undefined;
    order?: number;
    bannerType?: number;
    bannerTypeName?: string | undefined;

    constructor(data?: IBannerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.imageUrl = _data["imageUrl"];
            this.isActived = _data["isActived"];
            this.order = _data["order"];
            this.bannerType = _data["bannerType"];
            this.bannerTypeName = _data["bannerTypeName"];
        }
    }

    static fromJS(data: any): BannerDto {
        data = typeof data === 'object' ? data : {};
        let result = new BannerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["isActived"] = this.isActived;
        data["order"] = this.order;
        data["bannerType"] = this.bannerType;
        data["bannerTypeName"] = this.bannerTypeName;
        super.toJSON(data);
        return data;
    }
}

export interface IBannerDto extends IAuditableEntity {
    id?: string;
    imageUrl?: string | undefined;
    isActived?: boolean | undefined;
    order?: number;
    bannerType?: number;
    bannerTypeName?: string | undefined;
}

export class CreateBannerDto implements ICreateBannerDto {
    imageUrl?: string | undefined;
    isActived?: boolean | undefined;
    order?: number;
    bannerType?: number;

    constructor(data?: ICreateBannerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageUrl = _data["imageUrl"];
            this.isActived = _data["isActived"];
            this.order = _data["order"];
            this.bannerType = _data["bannerType"];
        }
    }

    static fromJS(data: any): CreateBannerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBannerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        data["isActived"] = this.isActived;
        data["order"] = this.order;
        data["bannerType"] = this.bannerType;
        return data;
    }
}

export interface ICreateBannerDto {
    imageUrl?: string | undefined;
    isActived?: boolean | undefined;
    order?: number;
    bannerType?: number;
}

export class CommonConfigDto extends AuditableEntity implements ICommonConfigDto {
    id?: string;
    aboutUsVi?: string | undefined;
    aboutUsEn?: string | undefined;
    hrPoliciesVi?: string | undefined;
    hrPoliciesEn?: string | undefined;
    submittingApplicationsIntroduceVi?: string | undefined;
    submittingApplicationsIntroduceEn?: string | undefined;
    applyTemplateForm?: string | undefined;
    applyTemplateFormName?: string | undefined;
    addressVi?: string | undefined;
    addressEn?: string | undefined;
    hotLine?: string | undefined;
    websiteUrl?: string | undefined;

    constructor(data?: ICommonConfigDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.aboutUsVi = _data["aboutUsVi"];
            this.aboutUsEn = _data["aboutUsEn"];
            this.hrPoliciesVi = _data["hrPoliciesVi"];
            this.hrPoliciesEn = _data["hrPoliciesEn"];
            this.submittingApplicationsIntroduceVi = _data["submittingApplicationsIntroduceVi"];
            this.submittingApplicationsIntroduceEn = _data["submittingApplicationsIntroduceEn"];
            this.applyTemplateForm = _data["applyTemplateForm"];
            this.applyTemplateFormName = _data["applyTemplateFormName"];
            this.addressVi = _data["addressVi"];
            this.addressEn = _data["addressEn"];
            this.hotLine = _data["hotLine"];
            this.websiteUrl = _data["websiteUrl"];
        }
    }

    static fromJS(data: any): CommonConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aboutUsVi"] = this.aboutUsVi;
        data["aboutUsEn"] = this.aboutUsEn;
        data["hrPoliciesVi"] = this.hrPoliciesVi;
        data["hrPoliciesEn"] = this.hrPoliciesEn;
        data["submittingApplicationsIntroduceVi"] = this.submittingApplicationsIntroduceVi;
        data["submittingApplicationsIntroduceEn"] = this.submittingApplicationsIntroduceEn;
        data["applyTemplateForm"] = this.applyTemplateForm;
        data["applyTemplateFormName"] = this.applyTemplateFormName;
        data["addressVi"] = this.addressVi;
        data["addressEn"] = this.addressEn;
        data["hotLine"] = this.hotLine;
        data["websiteUrl"] = this.websiteUrl;
        super.toJSON(data);
        return data;
    }
}

export interface ICommonConfigDto extends IAuditableEntity {
    id?: string;
    aboutUsVi?: string | undefined;
    aboutUsEn?: string | undefined;
    hrPoliciesVi?: string | undefined;
    hrPoliciesEn?: string | undefined;
    submittingApplicationsIntroduceVi?: string | undefined;
    submittingApplicationsIntroduceEn?: string | undefined;
    applyTemplateForm?: string | undefined;
    applyTemplateFormName?: string | undefined;
    addressVi?: string | undefined;
    addressEn?: string | undefined;
    hotLine?: string | undefined;
    websiteUrl?: string | undefined;
}

export class CreateCommonConfigDto extends AuditableEntity implements ICreateCommonConfigDto {
    aboutUsVi?: string | undefined;
    aboutUsEn?: string | undefined;
    hrPoliciesVi?: string | undefined;
    hrPoliciesEn?: string | undefined;
    submittingApplicationsIntroduceVi?: string | undefined;
    submittingApplicationsIntroduceEn?: string | undefined;
    applyTemplateForm?: string | undefined;
    applyTemplateFormName?: string | undefined;
    addressVi?: string | undefined;
    addressEn?: string | undefined;
    hotLine?: string | undefined;
    websiteUrl?: string | undefined;

    constructor(data?: ICreateCommonConfigDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aboutUsVi = _data["aboutUsVi"];
            this.aboutUsEn = _data["aboutUsEn"];
            this.hrPoliciesVi = _data["hrPoliciesVi"];
            this.hrPoliciesEn = _data["hrPoliciesEn"];
            this.submittingApplicationsIntroduceVi = _data["submittingApplicationsIntroduceVi"];
            this.submittingApplicationsIntroduceEn = _data["submittingApplicationsIntroduceEn"];
            this.applyTemplateForm = _data["applyTemplateForm"];
            this.applyTemplateFormName = _data["applyTemplateFormName"];
            this.addressVi = _data["addressVi"];
            this.addressEn = _data["addressEn"];
            this.hotLine = _data["hotLine"];
            this.websiteUrl = _data["websiteUrl"];
        }
    }

    static fromJS(data: any): CreateCommonConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommonConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aboutUsVi"] = this.aboutUsVi;
        data["aboutUsEn"] = this.aboutUsEn;
        data["hrPoliciesVi"] = this.hrPoliciesVi;
        data["hrPoliciesEn"] = this.hrPoliciesEn;
        data["submittingApplicationsIntroduceVi"] = this.submittingApplicationsIntroduceVi;
        data["submittingApplicationsIntroduceEn"] = this.submittingApplicationsIntroduceEn;
        data["applyTemplateForm"] = this.applyTemplateForm;
        data["applyTemplateFormName"] = this.applyTemplateFormName;
        data["addressVi"] = this.addressVi;
        data["addressEn"] = this.addressEn;
        data["hotLine"] = this.hotLine;
        data["websiteUrl"] = this.websiteUrl;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCommonConfigDto extends IAuditableEntity {
    aboutUsVi?: string | undefined;
    aboutUsEn?: string | undefined;
    hrPoliciesVi?: string | undefined;
    hrPoliciesEn?: string | undefined;
    submittingApplicationsIntroduceVi?: string | undefined;
    submittingApplicationsIntroduceEn?: string | undefined;
    applyTemplateForm?: string | undefined;
    applyTemplateFormName?: string | undefined;
    addressVi?: string | undefined;
    addressEn?: string | undefined;
    hotLine?: string | undefined;
    websiteUrl?: string | undefined;
}

export class ContactCustomerDto extends AuditableEntity implements IContactCustomerDto {
    id?: string;
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;

    constructor(data?: IContactCustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerEmail = _data["customerEmail"];
            this.content = _data["content"];
            this.attachFile = _data["attachFile"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): ContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerEmail"] = this.customerEmail;
        data["content"] = this.content;
        data["attachFile"] = this.attachFile;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        super.toJSON(data);
        return data;
    }
}

export interface IContactCustomerDto extends IAuditableEntity {
    id?: string;
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;
}

export enum ContactTypesEnum {
    RegisterToBuyAsset = 1,
    Contact = 2,
    Recruitment = 3,
}

export class CreateContactCustomerDto implements ICreateContactCustomerDto {
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;

    constructor(data?: ICreateContactCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerEmail = _data["customerEmail"];
            this.content = _data["content"];
            this.attachFile = _data["attachFile"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): CreateContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerEmail"] = this.customerEmail;
        data["content"] = this.content;
        data["attachFile"] = this.attachFile;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ICreateContactCustomerDto {
    customerName?: string | undefined;
    customerPhone?: string | undefined;
    customerEmail?: string | undefined;
    content?: string | undefined;
    attachFile?: string | undefined;
    receiveStatus?: boolean;
    contactType?: ContactTypesEnum;
}

export class SearchingContactCustomerDto implements ISearchingContactCustomerDto {
    name?: string | undefined;
    receiveStatus?: boolean | undefined;
    contactType?: ContactTypesEnum | undefined;

    constructor(data?: ISearchingContactCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.receiveStatus = _data["receiveStatus"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): SearchingContactCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingContactCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["receiveStatus"] = this.receiveStatus;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ISearchingContactCustomerDto {
    name?: string | undefined;
    receiveStatus?: boolean | undefined;
    contactType?: ContactTypesEnum | undefined;
}

export class ContactEmailDto extends AuditableEntity implements IContactEmailDto {
    id?: string;
    senderEmailAddress?: string | undefined;
    senderEmailPassword?: string | undefined;
    recieveCompany?: string | undefined;
    recieveDepartment?: string | undefined;
    recieverEmailAddress?: string | undefined;
    regardsText?: string | undefined;
    emailNoted?: string | undefined;
    descriptions?: string | undefined;
    isActive?: boolean;

    constructor(data?: IContactEmailDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.senderEmailAddress = _data["senderEmailAddress"];
            this.senderEmailPassword = _data["senderEmailPassword"];
            this.recieveCompany = _data["recieveCompany"];
            this.recieveDepartment = _data["recieveDepartment"];
            this.recieverEmailAddress = _data["recieverEmailAddress"];
            this.regardsText = _data["regardsText"];
            this.emailNoted = _data["emailNoted"];
            this.descriptions = _data["descriptions"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["senderEmailAddress"] = this.senderEmailAddress;
        data["senderEmailPassword"] = this.senderEmailPassword;
        data["recieveCompany"] = this.recieveCompany;
        data["recieveDepartment"] = this.recieveDepartment;
        data["recieverEmailAddress"] = this.recieverEmailAddress;
        data["regardsText"] = this.regardsText;
        data["emailNoted"] = this.emailNoted;
        data["descriptions"] = this.descriptions;
        data["isActive"] = this.isActive;
        super.toJSON(data);
        return data;
    }
}

export interface IContactEmailDto extends IAuditableEntity {
    id?: string;
    senderEmailAddress?: string | undefined;
    senderEmailPassword?: string | undefined;
    recieveCompany?: string | undefined;
    recieveDepartment?: string | undefined;
    recieverEmailAddress?: string | undefined;
    regardsText?: string | undefined;
    emailNoted?: string | undefined;
    descriptions?: string | undefined;
    isActive?: boolean;
}

export class CreateContactEmailDto implements ICreateContactEmailDto {
    senderEmailAddress?: string | undefined;
    senderEmailPassword?: string | undefined;
    recieveCompany?: string | undefined;
    recieveDepartment?: string | undefined;
    recieverEmailAddress?: string | undefined;
    regardsText?: string | undefined;
    emailNoted?: string | undefined;
    descriptions?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICreateContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderEmailAddress = _data["senderEmailAddress"];
            this.senderEmailPassword = _data["senderEmailPassword"];
            this.recieveCompany = _data["recieveCompany"];
            this.recieveDepartment = _data["recieveDepartment"];
            this.recieverEmailAddress = _data["recieverEmailAddress"];
            this.regardsText = _data["regardsText"];
            this.emailNoted = _data["emailNoted"];
            this.descriptions = _data["descriptions"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderEmailAddress"] = this.senderEmailAddress;
        data["senderEmailPassword"] = this.senderEmailPassword;
        data["recieveCompany"] = this.recieveCompany;
        data["recieveDepartment"] = this.recieveDepartment;
        data["recieverEmailAddress"] = this.recieverEmailAddress;
        data["regardsText"] = this.regardsText;
        data["emailNoted"] = this.emailNoted;
        data["descriptions"] = this.descriptions;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateContactEmailDto {
    senderEmailAddress?: string | undefined;
    senderEmailPassword?: string | undefined;
    recieveCompany?: string | undefined;
    recieveDepartment?: string | undefined;
    recieverEmailAddress?: string | undefined;
    regardsText?: string | undefined;
    emailNoted?: string | undefined;
    descriptions?: string | undefined;
    isActive?: boolean;
}

export class ContactClientDto implements IContactClientDto {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contents?: string | undefined;
    attachFile?: string | undefined;
    contactType?: ContactTypesEnum | undefined;

    constructor(data?: IContactClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contents = _data["contents"];
            this.attachFile = _data["attachFile"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): ContactClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contents"] = this.contents;
        data["attachFile"] = this.attachFile;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface IContactClientDto {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contents?: string | undefined;
    attachFile?: string | undefined;
    contactType?: ContactTypesEnum | undefined;
}

export class NewsCategoryDto extends AuditableEntity implements INewsCategoryDto {
    id?: string;
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    iconImage?: string | undefined;
    isActived?: boolean;

    constructor(data?: INewsCategoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
            this.categoryNameEN = _data["categoryNameEN"];
            this.iconImage = _data["iconImage"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): NewsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        data["categoryNameEN"] = this.categoryNameEN;
        data["iconImage"] = this.iconImage;
        data["isActived"] = this.isActived;
        super.toJSON(data);
        return data;
    }
}

export interface INewsCategoryDto extends IAuditableEntity {
    id?: string;
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    iconImage?: string | undefined;
    isActived?: boolean;
}

export class CreateNewsCategoryDto implements ICreateNewsCategoryDto {
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    iconImage?: string | undefined;
    isActived?: boolean;

    constructor(data?: ICreateNewsCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            this.categoryNameEN = _data["categoryNameEN"];
            this.iconImage = _data["iconImage"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): CreateNewsCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        data["categoryNameEN"] = this.categoryNameEN;
        data["iconImage"] = this.iconImage;
        data["isActived"] = this.isActived;
        return data;
    }
}

export interface ICreateNewsCategoryDto {
    categoryName?: string | undefined;
    categoryNameEN?: string | undefined;
    iconImage?: string | undefined;
    isActived?: boolean;
}

export class NewsDto extends AuditableEntity implements INewsDto {
    id?: string;
    title?: string | undefined;
    titleEN?: string | undefined;
    keyword?: string | undefined;
    content?: string | undefined;
    contentEN?: string | undefined;
    descriptions?: string | undefined;
    descriptionsEN?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean;
    featured?: boolean;
    isHomeView?: boolean;
    category?: NewsCategoryDto | undefined;

    constructor(data?: INewsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.titleEN = _data["titleEN"];
            this.keyword = _data["keyword"];
            this.content = _data["content"];
            this.contentEN = _data["contentEN"];
            this.descriptions = _data["descriptions"];
            this.descriptionsEN = _data["descriptionsEN"];
            this.imageUrl = _data["imageUrl"];
            this.imageName = _data["imageName"];
            this.views = _data["views"];
            this.categoryId = _data["categoryId"];
            this.isActived = _data["isActived"];
            this.featured = _data["featured"];
            this.isHomeView = _data["isHomeView"];
            this.category = _data["category"] ? NewsCategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["titleEN"] = this.titleEN;
        data["keyword"] = this.keyword;
        data["content"] = this.content;
        data["contentEN"] = this.contentEN;
        data["descriptions"] = this.descriptions;
        data["descriptionsEN"] = this.descriptionsEN;
        data["imageUrl"] = this.imageUrl;
        data["imageName"] = this.imageName;
        data["views"] = this.views;
        data["categoryId"] = this.categoryId;
        data["isActived"] = this.isActived;
        data["featured"] = this.featured;
        data["isHomeView"] = this.isHomeView;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface INewsDto extends IAuditableEntity {
    id?: string;
    title?: string | undefined;
    titleEN?: string | undefined;
    keyword?: string | undefined;
    content?: string | undefined;
    contentEN?: string | undefined;
    descriptions?: string | undefined;
    descriptionsEN?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    isActived?: boolean;
    featured?: boolean;
    isHomeView?: boolean;
    category?: NewsCategoryDto | undefined;
}

export class CreateNewsDto implements ICreateNewsDto {
    title?: string | undefined;
    titleEN?: string | undefined;
    keyword?: string | undefined;
    content?: string | undefined;
    contentEN?: string | undefined;
    descriptions?: string | undefined;
    descriptionsEN?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    featured?: boolean;
    isActived?: boolean | undefined;
    isHomeView?: boolean | undefined;

    constructor(data?: ICreateNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.titleEN = _data["titleEN"];
            this.keyword = _data["keyword"];
            this.content = _data["content"];
            this.contentEN = _data["contentEN"];
            this.descriptions = _data["descriptions"];
            this.descriptionsEN = _data["descriptionsEN"];
            this.imageUrl = _data["imageUrl"];
            this.imageName = _data["imageName"];
            this.views = _data["views"];
            this.categoryId = _data["categoryId"];
            this.featured = _data["featured"];
            this.isActived = _data["isActived"];
            this.isHomeView = _data["isHomeView"];
        }
    }

    static fromJS(data: any): CreateNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["titleEN"] = this.titleEN;
        data["keyword"] = this.keyword;
        data["content"] = this.content;
        data["contentEN"] = this.contentEN;
        data["descriptions"] = this.descriptions;
        data["descriptionsEN"] = this.descriptionsEN;
        data["imageUrl"] = this.imageUrl;
        data["imageName"] = this.imageName;
        data["views"] = this.views;
        data["categoryId"] = this.categoryId;
        data["featured"] = this.featured;
        data["isActived"] = this.isActived;
        data["isHomeView"] = this.isHomeView;
        return data;
    }
}

export interface ICreateNewsDto {
    title?: string | undefined;
    titleEN?: string | undefined;
    keyword?: string | undefined;
    content?: string | undefined;
    contentEN?: string | undefined;
    descriptions?: string | undefined;
    descriptionsEN?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    views?: number;
    categoryId?: string | undefined;
    featured?: boolean;
    isActived?: boolean | undefined;
    isHomeView?: boolean | undefined;
}

export class SearchingNewsDto implements ISearchingNewsDto {
    title?: string | undefined;
    featured?: boolean | undefined;

    constructor(data?: ISearchingNewsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.featured = _data["featured"];
        }
    }

    static fromJS(data: any): SearchingNewsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingNewsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["featured"] = this.featured;
        return data;
    }
}

export interface ISearchingNewsDto {
    title?: string | undefined;
    featured?: boolean | undefined;
}

export class PhotoDto implements IPhotoDto {
    id?: string;
    caption?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    thumbNail?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;

    constructor(data?: IPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caption = _data["caption"];
            this.imageUrl = _data["imageUrl"];
            this.imageName = _data["imageName"];
            this.thumbNail = _data["thumbNail"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caption"] = this.caption;
        data["imageUrl"] = this.imageUrl;
        data["imageName"] = this.imageName;
        data["thumbNail"] = this.thumbNail;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPhotoDto {
    id?: string;
    caption?: string | undefined;
    imageUrl?: string | undefined;
    imageName?: string | undefined;
    thumbNail?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
}

export class PrizeDto extends AuditableEntity implements IPrizeDto {
    id?: string;
    prizeNameVi?: string | undefined;
    prizeNameEn?: string | undefined;
    descriptionVi?: string | undefined;
    descriptionEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IPrizeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.prizeNameVi = _data["prizeNameVi"];
            this.prizeNameEn = _data["prizeNameEn"];
            this.descriptionVi = _data["descriptionVi"];
            this.descriptionEn = _data["descriptionEn"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): PrizeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrizeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prizeNameVi"] = this.prizeNameVi;
        data["prizeNameEn"] = this.prizeNameEn;
        data["descriptionVi"] = this.descriptionVi;
        data["descriptionEn"] = this.descriptionEn;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["imageUrl"] = this.imageUrl;
        super.toJSON(data);
        return data;
    }
}

export interface IPrizeDto extends IAuditableEntity {
    id?: string;
    prizeNameVi?: string | undefined;
    prizeNameEn?: string | undefined;
    descriptionVi?: string | undefined;
    descriptionEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    imageUrl?: string | undefined;
}

export class CreatePrizeDto implements ICreatePrizeDto {
    prizeNameVi?: string | undefined;
    prizeNameEn?: string | undefined;
    descriptionVi?: string | undefined;
    descriptionEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: ICreatePrizeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prizeNameVi = _data["prizeNameVi"];
            this.prizeNameEn = _data["prizeNameEn"];
            this.descriptionVi = _data["descriptionVi"];
            this.descriptionEn = _data["descriptionEn"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): CreatePrizeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePrizeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prizeNameVi"] = this.prizeNameVi;
        data["prizeNameEn"] = this.prizeNameEn;
        data["descriptionVi"] = this.descriptionVi;
        data["descriptionEn"] = this.descriptionEn;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ICreatePrizeDto {
    prizeNameVi?: string | undefined;
    prizeNameEn?: string | undefined;
    descriptionVi?: string | undefined;
    descriptionEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    imageUrl?: string | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class ForgetPasswordRequest implements IForgetPasswordRequest {
    email!: string;

    constructor(data?: IForgetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgetPasswordRequest {
    email: string;
}

export class RecruitmentCategoryDto extends AuditableEntity implements IRecruitmentCategoryDto {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;

    constructor(data?: IRecruitmentCategoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): RecruitmentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isActived"] = this.isActived;
        super.toJSON(data);
        return data;
    }
}

export interface IRecruitmentCategoryDto extends IAuditableEntity {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
}

export class CreateRecruitmentCategoryDto implements ICreateRecruitmentCategoryDto {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;

    constructor(data?: ICreateRecruitmentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): CreateRecruitmentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecruitmentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isActived"] = this.isActived;
        return data;
    }
}

export interface ICreateRecruitmentCategoryDto {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isActived?: boolean;
}

export class RecruitmentDto extends AuditableEntity implements IRecruitmentDto {
    id?: string | undefined;
    jobTitle?: string | undefined;
    jobTitleEN?: string | undefined;
    recruitQuantity?: number | undefined;
    expirationDate?: Date | undefined;
    responsibilities?: string | undefined;
    responsibilitiesEN?: string | undefined;
    requirements?: string | undefined;
    requirementsEN?: string | undefined;
    salaryAndBenefits?: string | undefined;
    salaryAndBenefitsEN?: string | undefined;
    location?: string | undefined;
    keyword?: string | undefined;
    recruitmentCategoryId?: string | undefined;
    imageUrl?: string | undefined;
    isActived?: boolean;
    category?: RecruitmentCategoryDto | undefined;

    constructor(data?: IRecruitmentDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jobTitle = _data["jobTitle"];
            this.jobTitleEN = _data["jobTitleEN"];
            this.recruitQuantity = _data["recruitQuantity"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.responsibilities = _data["responsibilities"];
            this.responsibilitiesEN = _data["responsibilitiesEN"];
            this.requirements = _data["requirements"];
            this.requirementsEN = _data["requirementsEN"];
            this.salaryAndBenefits = _data["salaryAndBenefits"];
            this.salaryAndBenefitsEN = _data["salaryAndBenefitsEN"];
            this.location = _data["location"];
            this.keyword = _data["keyword"];
            this.recruitmentCategoryId = _data["recruitmentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.isActived = _data["isActived"];
            this.category = _data["category"] ? RecruitmentCategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecruitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecruitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitle"] = this.jobTitle;
        data["jobTitleEN"] = this.jobTitleEN;
        data["recruitQuantity"] = this.recruitQuantity;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["responsibilities"] = this.responsibilities;
        data["responsibilitiesEN"] = this.responsibilitiesEN;
        data["requirements"] = this.requirements;
        data["requirementsEN"] = this.requirementsEN;
        data["salaryAndBenefits"] = this.salaryAndBenefits;
        data["salaryAndBenefitsEN"] = this.salaryAndBenefitsEN;
        data["location"] = this.location;
        data["keyword"] = this.keyword;
        data["recruitmentCategoryId"] = this.recruitmentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["isActived"] = this.isActived;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRecruitmentDto extends IAuditableEntity {
    id?: string | undefined;
    jobTitle?: string | undefined;
    jobTitleEN?: string | undefined;
    recruitQuantity?: number | undefined;
    expirationDate?: Date | undefined;
    responsibilities?: string | undefined;
    responsibilitiesEN?: string | undefined;
    requirements?: string | undefined;
    requirementsEN?: string | undefined;
    salaryAndBenefits?: string | undefined;
    salaryAndBenefitsEN?: string | undefined;
    location?: string | undefined;
    keyword?: string | undefined;
    recruitmentCategoryId?: string | undefined;
    imageUrl?: string | undefined;
    isActived?: boolean;
    category?: RecruitmentCategoryDto | undefined;
}

export class CreateRecruitmentDto implements ICreateRecruitmentDto {
    jobTitle?: string | undefined;
    jobTitleEN?: string | undefined;
    recruitQuantity?: number | undefined;
    expirationDate?: Date | undefined;
    responsibilities?: string | undefined;
    responsibilitiesEN?: string | undefined;
    requirements?: string | undefined;
    requirementsEN?: string | undefined;
    salaryAndBenefits?: string | undefined;
    salaryAndBenefitsEN?: string | undefined;
    location?: string | undefined;
    keyword?: string | undefined;
    recruitmentCategoryId?: string | undefined;
    imageUrl?: string | undefined;
    isActived?: boolean;

    constructor(data?: ICreateRecruitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobTitle = _data["jobTitle"];
            this.jobTitleEN = _data["jobTitleEN"];
            this.recruitQuantity = _data["recruitQuantity"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.responsibilities = _data["responsibilities"];
            this.responsibilitiesEN = _data["responsibilitiesEN"];
            this.requirements = _data["requirements"];
            this.requirementsEN = _data["requirementsEN"];
            this.salaryAndBenefits = _data["salaryAndBenefits"];
            this.salaryAndBenefitsEN = _data["salaryAndBenefitsEN"];
            this.location = _data["location"];
            this.keyword = _data["keyword"];
            this.recruitmentCategoryId = _data["recruitmentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.isActived = _data["isActived"];
        }
    }

    static fromJS(data: any): CreateRecruitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecruitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTitle"] = this.jobTitle;
        data["jobTitleEN"] = this.jobTitleEN;
        data["recruitQuantity"] = this.recruitQuantity;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["responsibilities"] = this.responsibilities;
        data["responsibilitiesEN"] = this.responsibilitiesEN;
        data["requirements"] = this.requirements;
        data["requirementsEN"] = this.requirementsEN;
        data["salaryAndBenefits"] = this.salaryAndBenefits;
        data["salaryAndBenefitsEN"] = this.salaryAndBenefitsEN;
        data["location"] = this.location;
        data["keyword"] = this.keyword;
        data["recruitmentCategoryId"] = this.recruitmentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["isActived"] = this.isActived;
        return data;
    }
}

export interface ICreateRecruitmentDto {
    jobTitle?: string | undefined;
    jobTitleEN?: string | undefined;
    recruitQuantity?: number | undefined;
    expirationDate?: Date | undefined;
    responsibilities?: string | undefined;
    responsibilitiesEN?: string | undefined;
    requirements?: string | undefined;
    requirementsEN?: string | undefined;
    salaryAndBenefits?: string | undefined;
    salaryAndBenefitsEN?: string | undefined;
    location?: string | undefined;
    keyword?: string | undefined;
    recruitmentCategoryId?: string | undefined;
    imageUrl?: string | undefined;
    isActived?: boolean;
}

export class SocialNetworkDto extends AuditableEntity implements ISocialNetworkDto {
    id?: string;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    socialNetworkTypeName?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: ISocialNetworkDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.linkUrl = _data["linkUrl"];
            this.socialNetworkTypeId = _data["socialNetworkTypeId"];
            this.socialNetworkTypeName = _data["socialNetworkTypeName"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): SocialNetworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["linkUrl"] = this.linkUrl;
        data["socialNetworkTypeId"] = this.socialNetworkTypeId;
        data["socialNetworkTypeName"] = this.socialNetworkTypeName;
        data["descriptions"] = this.descriptions;
        super.toJSON(data);
        return data;
    }
}

export interface ISocialNetworkDto extends IAuditableEntity {
    id?: string;
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    socialNetworkTypeName?: string | undefined;
    descriptions?: string | undefined;
}

export class CreateSocialNetworkDto implements ICreateSocialNetworkDto {
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: ICreateSocialNetworkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkUrl = _data["linkUrl"];
            this.socialNetworkTypeId = _data["socialNetworkTypeId"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): CreateSocialNetworkDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSocialNetworkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkUrl"] = this.linkUrl;
        data["socialNetworkTypeId"] = this.socialNetworkTypeId;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface ICreateSocialNetworkDto {
    linkUrl?: string | undefined;
    socialNetworkTypeId?: string | undefined;
    descriptions?: string | undefined;
}

export class SocialNetworkTypeDto implements ISocialNetworkTypeDto {
    id?: string;
    name?: string | undefined;
    type?: SocialNetworkTypesEnum;
    descriptions?: string | undefined;

    constructor(data?: ISocialNetworkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): SocialNetworkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface ISocialNetworkTypeDto {
    id?: string;
    name?: string | undefined;
    type?: SocialNetworkTypesEnum;
    descriptions?: string | undefined;
}

export enum SocialNetworkTypesEnum {
    Facebook = 1,
    Youtube = 2,
    Twitter = 3,
    Zalo = 4,
    Instagram = 5,
}

export class LoginRequest implements ILoginRequest {
    userName!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginRequest {
    userName: string;
    password: string;
    rememberMe?: boolean;
}

export class LoginResult implements ILoginResult {
    userName?: string | undefined;
    roles?: string[] | undefined;
    originalUserName?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    isLockedOut?: boolean;
    succeeded?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: ILoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.originalUserName = _data["originalUserName"];
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.isLockedOut = _data["isLockedOut"];
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): LoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["originalUserName"] = this.originalUserName;
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["isLockedOut"] = this.isLockedOut;
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ILoginResult {
    userName?: string | undefined;
    roles?: string[] | undefined;
    originalUserName?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    isLockedOut?: boolean;
    succeeded?: boolean;
    errorMessage?: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    password!: string;
    confirmPassword!: string;
    returnUrl?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    password: string;
    confirmPassword: string;
    returnUrl?: string | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export class WebsiteBodyMasterDto extends AuditableEntity implements IWebsiteBodyMasterDto {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    coverImageUrl?: string | undefined;
    coverImagePath?: string | undefined;
    coverImageName?: string | undefined;
    url?: string | undefined;
    type?: WebsiteBodyTypesEnum;
    websiteBodyContents?: WebsiteBodyContentDto[] | undefined;
    websiteBodyAttachFiles?: WebsiteBodyAttachFileDto[] | undefined;

    constructor(data?: IWebsiteBodyMasterDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.coverImagePath = _data["coverImagePath"];
            this.coverImageName = _data["coverImageName"];
            this.url = _data["url"];
            this.type = _data["type"];
            if (Array.isArray(_data["websiteBodyContents"])) {
                this.websiteBodyContents = [] as any;
                for (let item of _data["websiteBodyContents"])
                    this.websiteBodyContents!.push(WebsiteBodyContentDto.fromJS(item));
            }
            if (Array.isArray(_data["websiteBodyAttachFiles"])) {
                this.websiteBodyAttachFiles = [] as any;
                for (let item of _data["websiteBodyAttachFiles"])
                    this.websiteBodyAttachFiles!.push(WebsiteBodyAttachFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebsiteBodyMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new WebsiteBodyMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["coverImageUrl"] = this.coverImageUrl;
        data["coverImagePath"] = this.coverImagePath;
        data["coverImageName"] = this.coverImageName;
        data["url"] = this.url;
        data["type"] = this.type;
        if (Array.isArray(this.websiteBodyContents)) {
            data["websiteBodyContents"] = [];
            for (let item of this.websiteBodyContents)
                data["websiteBodyContents"].push(item.toJSON());
        }
        if (Array.isArray(this.websiteBodyAttachFiles)) {
            data["websiteBodyAttachFiles"] = [];
            for (let item of this.websiteBodyAttachFiles)
                data["websiteBodyAttachFiles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IWebsiteBodyMasterDto extends IAuditableEntity {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    coverImageUrl?: string | undefined;
    coverImagePath?: string | undefined;
    coverImageName?: string | undefined;
    url?: string | undefined;
    type?: WebsiteBodyTypesEnum;
    websiteBodyContents?: WebsiteBodyContentDto[] | undefined;
    websiteBodyAttachFiles?: WebsiteBodyAttachFileDto[] | undefined;
}

export enum WebsiteBodyTypesEnum {
    HomeOurService = 1,
    HomeAboutUs = 2,
    HomeTypicalIndex = 3,
    DevelopmentHistory = 4,
    HomeCustomerThinking = 5,
    HomeNewsInfo = 6,
}

export class WebsiteBodyContentDto extends AuditableEntity implements IWebsiteBodyContentDto {
    id?: string;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    websiteBodyMasterId?: string;
    websiteBodyMaster?: WebsiteBodyMasterDto | undefined;

    constructor(data?: IWebsiteBodyContentDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.url = _data["url"];
            this.websiteBodyMasterId = _data["websiteBodyMasterId"];
            this.websiteBodyMaster = _data["websiteBodyMaster"] ? WebsiteBodyMasterDto.fromJS(_data["websiteBodyMaster"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WebsiteBodyContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WebsiteBodyContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["url"] = this.url;
        data["websiteBodyMasterId"] = this.websiteBodyMasterId;
        data["websiteBodyMaster"] = this.websiteBodyMaster ? this.websiteBodyMaster.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IWebsiteBodyContentDto extends IAuditableEntity {
    id?: string;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    websiteBodyMasterId?: string;
    websiteBodyMaster?: WebsiteBodyMasterDto | undefined;
}

export class WebsiteBodyAttachFileDto extends AuditableEntity implements IWebsiteBodyAttachFileDto {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    attachFileUrl?: string | undefined;
    attachFilePath?: string | undefined;
    attachFileName?: string | undefined;
    attachFileSize?: number | undefined;
    websiteBodyMasterId?: string;
    websiteBodyMaster?: WebsiteBodyMasterDto | undefined;

    constructor(data?: IWebsiteBodyAttachFileDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.url = _data["url"];
            this.attachFileUrl = _data["attachFileUrl"];
            this.attachFilePath = _data["attachFilePath"];
            this.attachFileName = _data["attachFileName"];
            this.attachFileSize = _data["attachFileSize"];
            this.websiteBodyMasterId = _data["websiteBodyMasterId"];
            this.websiteBodyMaster = _data["websiteBodyMaster"] ? WebsiteBodyMasterDto.fromJS(_data["websiteBodyMaster"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WebsiteBodyAttachFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new WebsiteBodyAttachFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["url"] = this.url;
        data["attachFileUrl"] = this.attachFileUrl;
        data["attachFilePath"] = this.attachFilePath;
        data["attachFileName"] = this.attachFileName;
        data["attachFileSize"] = this.attachFileSize;
        data["websiteBodyMasterId"] = this.websiteBodyMasterId;
        data["websiteBodyMaster"] = this.websiteBodyMaster ? this.websiteBodyMaster.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IWebsiteBodyAttachFileDto extends IAuditableEntity {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    attachFileUrl?: string | undefined;
    attachFilePath?: string | undefined;
    attachFileName?: string | undefined;
    attachFileSize?: number | undefined;
    websiteBodyMasterId?: string;
    websiteBodyMaster?: WebsiteBodyMasterDto | undefined;
}

export class CreateWebsiteBodyMasterDto extends AuditableEntity implements ICreateWebsiteBodyMasterDto {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    coverImageUrl?: string | undefined;
    coverImagePath?: string | undefined;
    coverImageName?: string | undefined;
    url?: string | undefined;
    type?: WebsiteBodyTypesEnum;
    websiteBodyContents?: CreateWebsiteBodyContentDto[] | undefined;
    websiteBodyAttachFiles?: CreateWebsiteBodyAttachFileDto[] | undefined;

    constructor(data?: ICreateWebsiteBodyMasterDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.coverImagePath = _data["coverImagePath"];
            this.coverImageName = _data["coverImageName"];
            this.url = _data["url"];
            this.type = _data["type"];
            if (Array.isArray(_data["websiteBodyContents"])) {
                this.websiteBodyContents = [] as any;
                for (let item of _data["websiteBodyContents"])
                    this.websiteBodyContents!.push(CreateWebsiteBodyContentDto.fromJS(item));
            }
            if (Array.isArray(_data["websiteBodyAttachFiles"])) {
                this.websiteBodyAttachFiles = [] as any;
                for (let item of _data["websiteBodyAttachFiles"])
                    this.websiteBodyAttachFiles!.push(CreateWebsiteBodyAttachFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWebsiteBodyMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWebsiteBodyMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["coverImageUrl"] = this.coverImageUrl;
        data["coverImagePath"] = this.coverImagePath;
        data["coverImageName"] = this.coverImageName;
        data["url"] = this.url;
        data["type"] = this.type;
        if (Array.isArray(this.websiteBodyContents)) {
            data["websiteBodyContents"] = [];
            for (let item of this.websiteBodyContents)
                data["websiteBodyContents"].push(item.toJSON());
        }
        if (Array.isArray(this.websiteBodyAttachFiles)) {
            data["websiteBodyAttachFiles"] = [];
            for (let item of this.websiteBodyAttachFiles)
                data["websiteBodyAttachFiles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICreateWebsiteBodyMasterDto extends IAuditableEntity {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    coverImageUrl?: string | undefined;
    coverImagePath?: string | undefined;
    coverImageName?: string | undefined;
    url?: string | undefined;
    type?: WebsiteBodyTypesEnum;
    websiteBodyContents?: CreateWebsiteBodyContentDto[] | undefined;
    websiteBodyAttachFiles?: CreateWebsiteBodyAttachFileDto[] | undefined;
}

export class CreateWebsiteBodyContentDto extends AuditableEntity implements ICreateWebsiteBodyContentDto {
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreateWebsiteBodyContentDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CreateWebsiteBodyContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWebsiteBodyContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["url"] = this.url;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateWebsiteBodyContentDto extends IAuditableEntity {
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
}

export class CreateWebsiteBodyAttachFileDto extends AuditableEntity implements ICreateWebsiteBodyAttachFileDto {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    attachFileUrl?: string | undefined;
    attachFilePath?: string | undefined;
    attachFileName?: string | undefined;

    constructor(data?: ICreateWebsiteBodyAttachFileDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.url = _data["url"];
            this.attachFileUrl = _data["attachFileUrl"];
            this.attachFilePath = _data["attachFilePath"];
            this.attachFileName = _data["attachFileName"];
        }
    }

    static fromJS(data: any): CreateWebsiteBodyAttachFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWebsiteBodyAttachFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["url"] = this.url;
        data["attachFileUrl"] = this.attachFileUrl;
        data["attachFilePath"] = this.attachFilePath;
        data["attachFileName"] = this.attachFileName;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateWebsiteBodyAttachFileDto extends IAuditableEntity {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    url?: string | undefined;
    attachFileUrl?: string | undefined;
    attachFilePath?: string | undefined;
    attachFileName?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}